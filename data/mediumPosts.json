{
  "rss": {
    "channel": {
      "title": {
        "__cdata": " Stories by Safa Gayret on Medium "
      },
      "description": {
        "__cdata": " Stories by Safa Gayret on Medium "
      },
      "link": ["https://medium.com/@safa?source=rss-3ede4c648e44------2", "", ""],
      "image": {
        "url": "https://cdn-images-1.medium.com/fit/c/150/150/1*j_Ek9T7Vk87uS0UgvjBufQ.jpeg",
        "title": "Stories by Safa Gayret on Medium",
        "link": "https://medium.com/@safa?source=rss-3ede4c648e44------2"
      },
      "generator": "Medium",
      "lastBuildDate": "Sun, 09 Apr 2023 12:15:15 GMT",
      "webMaster": {
        "__cdata": " yourfriends@medium.com "
      },
      "item": [
        {
          "title": {
            "__cdata": " Form Builder nasıl yapılır (VueJS ile) "
          },
          "link": "https://safa.medium.com/form-builder-nas%C4%B1l-yap%C4%B1l%C4%B1r-vuejs-ile-87527be943bd?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/87527be943bd",
          "category": [
            {
              "__cdata": " jotform "
            },
            {
              "__cdata": " vuejs "
            },
            {
              "__cdata": " formbuilder "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Sun, 09 Apr 2023 12:14:14 GMT",
          "updated": "2023-04-09T12:14:14.724Z",
          "encoded": {
            "__cdata": " <p>VueJS ile (<a href=\"https://www.jotform.com\"><strong>Jotform</strong></a><strong> </strong>tarzı) form builder yapmanız gerektiğinde maalesef internette pek kaynak bulamayacaksınız, madem kaynak yok o halde beraber oluşturalım.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*T9YMOmuE3k_x3goJjmSOoQ.png\" /><figcaption>[Görsel 1] Bittiği zaman böyle görünecek, <a href=\"https://form-builder-vuejs.netlify.app/\">https://form-builder-vuejs.netlify.app</a></figcaption></figure><p>Bir form builder dört temel component’ten bir araya gelir, <strong>Toolbox</strong>, <strong>Designer</strong>, <strong>Preview</strong>, <strong>Properties</strong>. Elbette ihtiyaca göre anlamlı en küçük yapıları componentleştirebiliriz. Bu complex bir yapıyı en kolay anlatabileceğim şekilde kodlamayı seçtim.</p><pre> &quot;dependencies&quot;: {<br> &quot;remixicon&quot;: &quot;^2.5.0&quot;,<br> &quot;vue&quot;: &quot;^3.2.45&quot;<br> },</pre><p>Bağımlılık olarak yalnızca icon paketi olan <strong>remixicon </strong>kullandım. Global state management’e dahi başvurmadım.</p><p>(bkz: <a href=\"https://safa.medium.com/vuex-olmasa-da-olur-mu-cecae3085bba\">Vuex olmasa da olur mu?</a>)</p><h3>Hadi başlayalım</h3><p>Az sonra oluşturacağımız temel componentleri, <strong>App.vue</strong> içerisinde kullanacağız.</p><pre>&lt;div class=&quot;form-builder&quot;&gt;<br> &lt;div class=&quot;form-builder-header&quot;&gt;<br> &lt;h1&gt;Form Builder&lt;/h1&gt;<br> &lt;div class=&quot;btn-group&quot;&gt;<br> &lt;button @click=&quot;toggleMode&quot;&gt;{{ mode === &#39;designer&#39; ? &#39;Preview&#39; : &#39;Designer&#39; }}&lt;/button&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br> &lt;div class=&quot;form-builder-wrapper&quot;&gt;<br> &lt;Toolbox /&gt;<br> &lt;div class=&quot;main&quot;&gt;<br> &lt;Designer v-if=&quot;mode === &#39;designer&#39;&quot; v-model=&quot;formBuilderJSON&quot; @on-select-field=&quot;changeSelectedField&quot; /&gt;<br> &lt;Preview v-else v-model=&quot;formBuilderJSON&quot; /&gt;<br> &lt;/div&gt;<br> &lt;Properties v-model=&quot;selectedField&quot; /&gt;<br> &lt;/div&gt;<br>&lt;/div&gt;</pre><p><a href=\"https://github.com/gayret/form-builder-vuejs/blob/main/src/components/Toolbox.vue\">Toolbox.vue</a> componenti <em>Görsel 1</em>&#39;de solda görünen araç kutusundan ibaret, bu kutunun kabiliyetleri şunlar olmalı. Form oluştururken kullanabileceğimiz tüm field türlerini listelemeli. Bu fieldlar kullanıcı tarafından sürükleme yoluyla alınmak istendiğinde event.dataTransfer’e set etmeli.</p><p>Tamam, bu durumda içerisinde bir onDrag fonksiyonu olan bir component işimizi görecektir.</p><pre>&lt;script setup&gt;<br>import tools from &#39;../composables/tools&#39;<br>import Icon from &#39;./Icon.vue&#39;<br><br>const onDrag = (e, tool) =&gt; {<br> e.dataTransfer.setData(&#39;text/plain&#39;, JSON.stringify(tool))<br>}<br>&lt;/script&gt;<br><br>&lt;template&gt;<br> &lt;div class=&quot;card toolbox&quot;&gt;<br> &lt;h4&gt;Toolbox&lt;/h4&gt;<br> &lt;ul&gt;<br> &lt;li v-for=&quot;tool in tools&quot; :key=&quot;tool.title&quot; draggable=&quot;true&quot; @dragstart=&quot;onDrag($event, tool)&quot;&gt;<br> &lt;span class=&quot;icon&quot;&gt;<br> &lt;Icon :name=&quot;tool.icon&quot; /&gt;<br> &lt;/span&gt;<br> &lt;span class=&quot;title&quot;&gt;<br> {{ tool.title }}<br> &lt;/span&gt;<br> &lt;/li&gt;<br> &lt;/ul&gt;<br> &lt;/div&gt;<br>&lt;/template&gt;</pre><p>İyi başladık. Toolbox’ımız hazır bile.</p><p>Şimdi biraz karmaşık olan <a href=\"https://github.com/gayret/form-builder-vuejs/blob/main/src/components/Designer.vue\"><strong>Designer.vue</strong></a> Componentimizi kodlayalım.</p><blockquote>Designer, Preview ve Properties componentleri two way binding’e ihtiyaç duyuyor. Kullanıcının yapacağı her hareketten ilgili componentlerin haberdar olması gerekiyor. Bunu yapabilmeniz için parent component ile child component arasında two way binding ilişkisi kurmayı biliyor olmanız lazım. Endişelenmeyin onu da anlatmıştım zamanında<br>(bkz: <a href=\"https://safa.medium.com/parent-component-ile-child-component-aras%C4%B1nda-v-model-ili%C5%9Fkisi-kurmak-859db2ee7d79\">Parent Component ile Child Component arasında v-model ilişkisi kurmak</a>)</blockquote><p>Designer componentimizden beklentilerimiz;</p><ul><li>Form ekranını satırlara ve sütunlara bölebilmeli</li><li>Gerektiğinde satır ve sütunların title ve description bilgilerini güncelleyebilmeli</li><li>Toolbox’tan sürüklenme yoluyla alınan field’lar sütunlara bırakıldığında field’ı temsil eden bir card oluşturabilmeli</li><li>Gerektiğinde oluşturulan field’ları silebilmeli</li><li>Satır ve sütunların yerlerini değiştirebilmeli</li><li>Odaklanılan field’ın özellikleri değiştirilebilsin diye, designler üzerindeki field’lara tıklandığında (hiyerarşik olarak) bir üstteki componenti bilgilendirmeli (Bu kısım karmaşık görünebilir, Properties.vue componentini yazarken daha anlaşılır hale gelecek)</li></ul><p>Toolbox’taki onDrag fonksiyonuna benzer bir onDrop fonksiyonu yazalım.</p><pre>const onDrop = (e, col) =&gt; {<br> const field = JSON.parse(e.dataTransfer.getData(&#39;text/plain&#39;))<br> col.fields.push(field)<br>}</pre><p>Bu fonksiyon herhangi bir sütunun üzerine bir field bırakıldığında çalışacak. Diğer kabiliyetleri nasıl kazandırdığımı <a href=\"https://github.com/gayret/form-builder-vuejs/blob/main/src/components/Designer.vue\">componenti </a>inceleyerek öğrebilirsiniz.</p><p>Designer componentimiz de hazır.</p><p>Sırada <a href=\"https://github.com/gayret/form-builder-vuejs/blob/main/src/components/Preview.vue\"><strong>Preview.vue</strong></a> var</p><p>Bu component’ten beklentilerimiz şunlar;</p><ul><li>Designer componentinde oluşturulan satır ve sütunları göstermeli</li><li>Bu sütunların içerisindeki field’ları render etmeli.</li></ul><p>Preview componenti’nde VueJS yazarken pek başvurulmayan bir yönteme başvurmamız gerekiyor. HyperScript ile HTML element oluşturmak ve ekranda göstermek.</p><p>Yapması tarif etmekten daha kolay. VueJS içerisinde HyperScript gömülü geliyor. Nasıl kullanılacağı da <a href=\"https://vuejs.org/guide/extras/render-function.html\">dökümanda mevcut</a>. Yine de kısaca Türkçeleştireyim.</p><pre>h(&#39;div&#39;)</pre><p>h fonksiyonuna parametre olarak bir HTML element’in ihtiyaç duyacağı prop’ları geçiyoruz. Aşağıdaki gibi.</p><pre>h(&#39;div&#39;, { class: &#39;bar&#39;, innerHTML: &#39;hello&#39; })</pre><p>Form builder içerisindeki Preview.vue componenti ‘formBuilderJSON’ adlı bir JSON bekliyor. Bunu App.vue içerisinde reaktive bir şekilde oluşturup göndermemiz gerekiyor. Kullanıcının oluşturacağı / oluşturduğu form ile ilgili tüm detaylar bu dinamik JSON içerisinde.</p><p>Preview componenti kendisine verilen bu JSON’daki fieldları ‘renderer’ fonksiyonu ayıklayıp anlamlı çıktılar döndürüyor.</p><pre>const renderer = (payload) =&gt; {<br> const { type, options, value, placeholder } = payload.field<br><br> switch (type) {<br> case &#39;text&#39;:<br> return h(&#39;input&#39;, { type, value, placeholder })<br> case &#39;checkbox&#39;:<br> return h(&#39;input&#39;, { type, value, placeholder })<br> case &#39;radio&#39;:<br> return h(&#39;input&#39;, { type, value, placeholder })<br> case &#39;datetime-local&#39;:<br> return h(&#39;input&#39;, { type, value, placeholder })<br> case &#39;email&#39;:<br> return h(&#39;input&#39;, { type, value, placeholder })<br> case &#39;number&#39;:<br> return h(&#39;input&#39;, { type, value, placeholder })<br> case &#39;password&#39;:<br> return h(&#39;input&#39;, { type, value, placeholder })<br> case &#39;textarea&#39;:<br> return h(&#39;textarea&#39;, { value, placeholder })<br> case &#39;select&#39;:<br> return h(&#39;select&#39;, options.map((option) =&gt; h(&#39;option&#39;, option.label)))<br> default:<br> return h(&#39;div&#39;, &#39;Unknown field type&#39;)<br> }<br>}</pre><p>Bu fonksiyona form builder’ın motoru diyebiliriz. Tüm fieldları özellikleriyle beraber oluşturan ekrana basan fonksiyon bu. İçerisindeki case sayısını artırarak dilediğiniz kadar yaratıcı form elementleri oluşturabilirsiniz. Ben daha az karmaşık olması nedeniyle bu kadar element örneği verdim.</p><p><em>Vuhuu en karmaşık component’i yazdık bitirdik. Bizden korkulur :)</em></p><p>Sırada <a href=\"https://github.com/gayret/form-builder-vuejs/blob/main/src/components/Properties.vue\"><strong>Properties.vue</strong></a> var</p><p>Bu component’ten beklentilerimiz;</p><ul><li>Designer içerisinde üzerine tıklanmış (seçilmiş) field’la ilgili bilgileri gösterecek</li><li>Ve bu bilgileri değiştirmemize olanak verecek</li></ul><p>Preview.vue’yu yazmış biri için bu çocuk oyuncağı. App.vue’ya bakarak kendinize hatırlatabilirsiniz. Yine two way binding ile <strong>selectedField </strong>adlı object’i App.vue ile Properties.vue arasında taşımamız gerekiyor.</p><p>Sonrasında Properties.vue içerisinde elimizdeki field’ın ayarlarını yapabileceği elementleri oluşturalım.</p><pre>&lt;div class=&quot;settings&quot;&gt;<br> &lt;h4&gt;Field properties&lt;/h4&gt;<br> &lt;div class=&quot;propertie&quot;&gt;<br> &lt;div class=&quot;propertie-header&quot;&gt;<br> &lt;div class=&quot;icon-and-title&quot;&gt;<br> &lt;Icon size=&quot;30px&quot; :name=&quot;field.icon&quot; :key=&quot;field.icon&quot; /&gt;<br> &lt;input type=&quot;text&quot; v-model=&quot;field.title&quot;&gt;<br> &lt;/div&gt;<br> &lt;div class=&quot;id&quot;&gt;{{ field.id }}&lt;/div&gt;<br> &lt;/div&gt;<br> &lt;div class=&quot;propertie-content&quot;&gt;<br> &lt;div class=&quot;propertie-row&quot;&gt;<br> &lt;div class=&quot;type&quot; v-if=&quot;isInput(field.type)&quot;&gt;<br> &lt;label for=&quot;type&quot;&gt;Type&lt;/label&gt;<br> &lt;select name=&quot;type&quot; id=&quot;type&quot; v-model=&quot;field.type&quot;&gt;<br> &lt;option value=&quot;text&quot;&gt;Text&lt;/option&gt;<br> &lt;option value=&quot;number&quot;&gt;Number&lt;/option&gt;<br> &lt;option value=&quot;email&quot;&gt;Email&lt;/option&gt;<br> &lt;option value=&quot;password&quot;&gt;Password&lt;/option&gt;<br> &lt;option value=&quot;datetime-local&quot;&gt;Datetime&lt;/option&gt;<br> &lt;/select&gt;<br> &lt;/div&gt;<br><br> &lt;div class=&quot;value&quot; v-if=&quot;isInput(field.type) || field.type === &#39;textarea&#39;&quot;&gt;<br> &lt;label for=&quot;value&quot;&gt;Value&lt;/label&gt;<br> &lt;input type=&quot;text&quot; v-model=&quot;field.value&quot;&gt;<br> &lt;/div&gt;<br><br> &lt;div class=&quot;placeholder&quot; v-if=&quot;isInput(field.type) || field.type === &#39;textarea&#39;&quot;&gt;<br> &lt;label for=&quot; placeholder&quot;&gt;Placeholder&lt;/label&gt;<br> &lt;input type=&quot;text&quot; v-model=&quot;field.placeholder&quot;&gt;<br> &lt;/div&gt;<br><br> &lt;div class=&quot;options&quot; v-if=&quot;field.type === &#39;select&#39;&quot;&gt;<br> &lt;label for=&quot;options&quot;&gt;Options&lt;/label&gt;<br> &lt;div class=&quot;option&quot; v-for=&quot;(option, optionIndex) in field.options&quot; :key=&quot;option.id&quot;&gt;<br> &lt;input type=&quot;text&quot; v-model=&quot;option.label&quot;&gt;<br> &lt;button class=&quot;btn&quot; @click=&quot;onRemoveOption(field.options, optionIndex)&quot;&gt;<br> &lt;Icon name=&quot;close&quot; /&gt;<br> &lt;/button&gt;<br> &lt;/div&gt;<br> &lt;button class=&quot;btn&quot; @click=&quot;onAddOption(field.options)&quot;&gt;<br> &lt;Icon name=&quot;add&quot; /&gt;<br> Add Option<br> &lt;/button&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br>&lt;/div&gt;</pre><p>Kullanıcının seçtiği elementin arka plan rengini ve/veya yazı rengini değiştirebilmesini istiyorsak “color” type’lı inputlar da ekleyelim.</p><pre>&lt;div class=&quot;design&quot;&gt;<br> &lt;h4&gt;Design properties&lt;/h4&gt;<br> &lt;div class=&quot;propertie&quot;&gt;<br> &lt;div class=&quot;background-color&quot;&gt;<br> &lt;label for=&quot;background-color&quot;&gt;Background color&lt;/label&gt;<br> &lt;input type=&quot;color&quot; v-model=&quot;field.style.backgroundColor&quot;&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br> &lt;div class=&quot;propertie&quot;&gt;<br> &lt;div class=&quot;color&quot;&gt;<br> &lt;label for=&quot;color&quot;&gt;Font color&lt;/label&gt;<br> &lt;input type=&quot;color&quot; v-model=&quot;field.style.color&quot;&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br>&lt;/div&gt;</pre><p>Hepsi bu kadar. Artık VueJS ile yazılmış bir form builder’ımız var.</p><p>Repo: <a href=\"https://github.com/gayret/form-builder-vuejs\">https://github.com/gayret/form-builder-vuejs</a></p><p>Live: <a href=\"https://form-builder-vuejs.netlify.app\">https://form-builder-vuejs.netlify.app</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=87527be943bd\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " FrontEnd’de çok şey değişiyor: SPA öldü, yaşasın SSR "
          },
          "link": "https://safa.medium.com/frontendde-%C3%A7ok-%C5%9Fey-de%C4%9Fi%C5%9Fiyor-spa-%C3%B6ld%C3%BC-ya%C5%9Fas%C4%B1n-ssr-732a897ab107?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/732a897ab107",
          "category": [
            {
              "__cdata": " ssrs "
            },
            {
              "__cdata": " nextjs "
            },
            {
              "__cdata": " sap "
            },
            {
              "__cdata": " vuejs "
            },
            {
              "__cdata": " react "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Wed, 29 Mar 2023 11:49:22 GMT",
          "updated": "2023-03-29T11:53:40.612Z",
          "encoded": {
            "__cdata": " <figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/1*T_hdLmcueDAkcMo_2YQCUg.png\" /><figcaption>Görsel Kaynağı: <a href=\"https://www.velv.pt/updates/server-side-rendering\">https://www.velv.pt/updates/server-side-rendering</a></figcaption></figure><p>Malumunuz ReactJS, web uygulamaları geliştirirken kullanılan en popüler JavaScript kütüphanesi. Son zamanlarda, ReactJS yerine NextJS kullanımının teşvik edildiğini duymuş olabilirsiniz. Bunun sebebi ReactJS’in <strong>yeni </strong>dökümanında yer alan <strong>Installation </strong>kısmı. Burada artık <em>create-react-app</em> yerine <strong>create-next-app</strong> yazıyor.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/210/1*KUpra0uvIf_-MVQWiQm1Ew.png\" /><figcaption><a href=\"https://react.dev/learn/start-a-new-react-project\">https://react.dev/learn/start-a-new-react-project</a></figcaption></figure><p>Bu gelişme ile birlikte, yakın gelecekte SPA’nın biteceğini, SSR’ın popülerleşeceğini düşünmek yanlış olmaz. Çünkü ReactJS, FrontEnd dünyasını domine eden bir kütüphane, hem çok sayıda developer tarafından kullanılıyor hem de alternatifi diğer framework’ler (VueJS vb.) ReactJS’in izinden gidiyor.</p><h3>Nedir bu SPA?</h3><p><strong>S</strong>ingle-<strong>P</strong>age <strong>A</strong>pplication, tek bir HTML sayfası ve JavaScript kullanarak web uygulamasının tüm içeriğini dinamik olarak oluşturur. Kullanıcılar bu tek sayfa üzerinde gezinirler ve sayfa yenileme işlemi gerektirmez. SPA kullanımı, daha iyi performans, daha hızlı kullanıcı arayüzü ve daha iyi kullanıcı deneyimi gibi avantajlar sunar.</p><p>Ancak, SPA’lar bazı dezavantajlar da taşır. Örneğin, arama motorları için optimize edilmiş sayfaların oluşturulması zordur. Ayrıca, yavaş internet bağlantılarına sahip kullanıcılar için, SPA’lar yüklenme süreleri nedeniyle yavaş veya kullanılamaz hale gelebilirler.</p><h3>Peki SSR nedir?</h3><p><strong>S</strong>erver-<strong>S</strong>ide <strong>R</strong>endering, web uygulamasının sunucu tarafında oluşturulan HTML sayfalarını kullanarak uygulamanın içeriğini ortaya koyar. Bu sayede, sunucu tarafında oluşturulan HTML sayfaları arama motorları tarafından daha iyi indekslenebilir ve daha iyi SEO sağlar. Ayrıca, yavaş internet bağlantılarına sahip kullanıcılar için bile sayfa yükleme süresi oldukça iyidir.</p><p>NextJS, ReactJS’in üzerine inşa edilen bir framework’tür. NextJS, hem SPA hem de SSR kullanımını destekler ve kullanıcılara en iyi deneyimi sağlamak için otomatik olarak doğru yönlendirmeyi yapar. NextJS, SPA’nın sağladığı avantajları korurken, SSR’nin sağladığı avantajları da sunar. Bu nedenle, NextJS kullanımı SPA’ya kıyasla daha önerilen bir yöntemdir.</p><h3>VueJS cephesinde neler olacak?</h3><p>VueJS de rakibi ReactJS gibi SSR framework sağlıyor. Adı da benziyor üstelik, NuxtJS. Ancak NuxtJS, NextJS’e kıyasla daha az stabil ve sektörde pek tercih edilmiyor. Teknik olarak aynı şeyi yapıyor olsalar da NextJS’in metodolojileri daha çok kabul görüyor.</p><p>Öyle sanıyorum ki, VueJS’in de SPA’dan SSR’a geçiş planı vardır ancak ReactJS’in bu beklenmedik hamlesi sonucunda hızlıca pozisyon alacak kadar hazır değildir.</p><p>Tüm bu gelişmeler VueJS, Svelte ve AngularJS gibi SPA teknolojilerinin sonunun habercisi olabilir.</p><p>Özetle sevelim ya da sevmeyelim, SSR teknolojilerine geçiş yapmak zorunda kalacağız.</p><h3>SSR’a geçişimiz iyi mi kötü mü?</h3><h3>Developer deneyimi</h3><p>Developer deneyimi açısından SSR uzun vadede daha verimli ve keyifli bir teknoloji. Çünkü SPA’larda tabiri uygunsa <a href=\"https://tr.wiktionary.org/wiki/Her_yi%C4%9Fidin_bir_yo%C4%9Furt_yiyi%C5%9Fi_vard%C4%B1r\">her yiğit kafasına göre yoğurt yiyor</a>. SSR (NuxtJS bile) çok daha katı kuralların olduğu bir development süreci tanıyor. Böylece SSR ile geliştirilmiş projelere dahil olduğumuzda saçımızı başımızı daha az yoluyoruz. Yine de SPA’ya çok alışmış olan developerlar özellikle API isteklerinin sonuçlarını organize ederken browser’ın console’unu kullanamadıkları için SSR’a ilk bakışlarında yabancılık çekecekler.</p><h3>Kullanıcı deneyimi</h3><p>Aynı işi yapan, doğru düzgün geliştirimiş bir SPA ve SSR projesini kullanıcıya versek, muhtemelen aralarındaki farkı pek ayırt edemez ancak sayfalar yüklenirken neredeyse beklenmemesi, sayfaların içerisindeki component’ler ile birlikte çat diye hazır oluşu gibi detaylar düşünüldüğünde, kullanıcı da SSR’dan daha çok keyif alacaktır.</p><p><em>Bu makale yazılırken yer yer </em><strong><em>ChatGPT</em></strong><em>’den faydalanılmıştır.</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=732a897ab107\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " Hemen kullanabileceğiniz 4 yeni HTML element "
          },
          "link": "https://safa.medium.com/hemen-kullanabilece%C4%9Finiz-4-yeni-html-element-5b3be5587a67?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/5b3be5587a67",
          "category": [
            {
              "__cdata": " noscript "
            },
            {
              "__cdata": " new-elements "
            },
            {
              "__cdata": " html "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Sun, 18 Sep 2022 20:41:43 GMT",
          "updated": "2022-09-23T05:13:11.270Z",
          "encoded": {
            "__cdata": " <h4>Okullarda üzerine düşülmeyen, detaylarıyla incelenmeyen HTML, verimli kullanıldığında fazladan JS ve CSS yazmaktan kurtaran bir teknoloji.</h4><p>Sanılanın aksine HTML, tüm browser’lar tarafından desteklenen yeni özellikler de kazanıyor. Takip etmekte fayda var.</p><p>Gelin gönül rahatlığıyla kullanabileceğiniz 4 yeni elementi inceleyelim.</p><h3>Datalist</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/291/1*UKuYI8Ms0JVdvYUDfWUqgg.png\" /></figure><p>Standart input ile kullanıcılardan karmaşık (kuralsız) veriler alabiliriz. En fazla placeholder attribute ile kullanıcıyı bilgilendirerek tam olarak istediğimiz bilginin ne olduğunu belirtebiliriz. Yeni gelen Datalist elementi ile bundan fazlasını yapabiliyoruz. Kullanıcıya seçenekler sunup, bunlar içerisinde arama ve seçme imkanı sunabiliyoruz.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*kIK3d9-vufYV5bgco78mJg.png\" /><figcaption>Kullanılabilen browserlar</figcaption></figure><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodepen.io%2Fgayret%2Fembed%2Fpreview%2FrNvmWrd%3Fdefault-tabs%3Dhtml%252Cresult%26height%3D600%26host%3Dhttps%253A%252F%252Fcodepen.io%26slug-hash%3DrNvmWrd&amp;display_name=CodePen&amp;url=https%3A%2F%2Fcodepen.io%2Fgayret%2Fpen%2FrNvmWrd&amp;image=https%3A%2F%2Fshots.codepen.io%2Fgayret%2Fpen%2FrNvmWrd-512.jpg%3Fversion%3D1663526214&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=codepen\" width=\"800\" height=\"600\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/249f4b235e10674a04f1a0ff0a15a4ea/href\">https://medium.com/media/249f4b235e10674a04f1a0ff0a15a4ea/href</a></iframe><h3>Details</h3><p>Toggle ile açılıp kapanabilen detaylı içerik gösterimini CSS ve/veya JS yardımı olmaksızın yapmanın yolu yoktu. Details elementi çıkıncaya kadar, kullanımı da oldukça kolay.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodepen.io%2Fgayret%2Fembed%2Fpreview%2FOJZmpWw%3Fdefault-tabs%3Dhtml%252Cresult%26height%3D600%26host%3Dhttps%253A%252F%252Fcodepen.io%26slug-hash%3DOJZmpWw&amp;display_name=CodePen&amp;url=https%3A%2F%2Fcodepen.io%2Fgayret%2Fpen%2FOJZmpWw&amp;image=https%3A%2F%2Fshots.codepen.io%2Fgayret%2Fpen%2FOJZmpWw-512.jpg%3Fversion%3D1663532965&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=codepen\" width=\"800\" height=\"600\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/0d90e0e60029bec5da19742a689a0a41/href\">https://medium.com/media/0d90e0e60029bec5da19742a689a0a41/href</a></iframe><h3>Dialog</h3><p>Kullanıcı bir işlem yaparken ya da yaptıktan sonra gerçekleştirilen işlemle ilgili onay almak veya bilgi vermek developer’ın asli görevlerindendir. Şimdiye kadar bunu karmaşık JS komutlarıyla gerçekleştiriyorduk. Artık kullanımı çok kolay olan bir HTML element ile her şey yolunda.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodepen.io%2Fgayret%2Fembed%2Fpreview%2FKKRmWWj%3Fdefault-tabs%3Dhtml%252Cresult%26height%3D600%26host%3Dhttps%253A%252F%252Fcodepen.io%26slug-hash%3DKKRmWWj&amp;display_name=CodePen&amp;url=https%3A%2F%2Fcodepen.io%2Fgayret%2Fpen%2FKKRmWWj&amp;image=https%3A%2F%2Fshots.codepen.io%2Fgayret%2Fpen%2FKKRmWWj-512.jpg%3Fversion%3D1663533167&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=codepen\" width=\"800\" height=\"600\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/830d272c209c7590b20ccf347446194a/href\">https://medium.com/media/830d272c209c7590b20ccf347446194a/href</a></iframe><h3>Figure</h3><p>Bir fotoğraf veya kod parçacığı yayınlarken altına üstüne kısa caption bilgi girmemiz gerektiğinde, ideal görünüm elde etmek için satırlarca CSS yazmamız gerekiyordu. Artık <strong>figure </strong>ve içerisinde <strong>figcaption </strong>elementlerini kullanarak CSS yazmadan ideale en yakın görüntüyü elde etmek mümkün.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodepen.io%2Fgayret%2Fembed%2Fpreview%2FxxjdqrR%3Fdefault-tabs%3Dhtml%252Cresult%26height%3D600%26host%3Dhttps%253A%252F%252Fcodepen.io%26slug-hash%3DxxjdqrR&amp;display_name=CodePen&amp;url=https%3A%2F%2Fcodepen.io%2Fgayret%2Fpen%2FxxjdqrR&amp;image=https%3A%2F%2Fshots.codepen.io%2Fgayret%2Fpen%2FxxjdqrR-512.jpg%3Fversion%3D1663533508&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=codepen\" width=\"800\" height=\"600\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/df8710e3e218295d9b46f7356e1b53fc/href\">https://medium.com/media/df8710e3e218295d9b46f7356e1b53fc/href</a></iframe><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5b3be5587a67\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " Kendi toast mesajınızı yazın "
          },
          "link": "https://safa.medium.com/kendi-toast-mesaj%C4%B1n%C4%B1z%C4%B1-yaz%C4%B1n-a58495cf0f20?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/a58495cf0f20",
          "category": [
            {
              "__cdata": " message "
            },
            {
              "__cdata": " javascript "
            },
            {
              "__cdata": " toast-message "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Sat, 17 Sep 2022 20:06:33 GMT",
          "updated": "2022-09-17T20:07:38.865Z",
          "encoded": {
            "__cdata": " <h4>Web uygulamalarda temel ihtiyaçlardan biri, bir işlem gerçekleşirken veya gerçekleştikten sonra kullanıcının haberdar edilmesidir. Toast mesajlar burada yardımımıza yetişir. Bunu hakkıyla yapan yığınla NPM paket var ancak bazen yeterli olmayabiliyorlar, araya girip bir şeyleri değiştirmemiz gerekiyor. Peki kendimiz yazsak nasıl yazardık?</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/745/1*8HXCSh1MtmxkBM5vqwHUyQ.png\" /></figure><p>Toast mesaj temelde kolayca call edilebilen bir function olmalıdır.</p><pre>message.success(&#39;This is a success message&#39;, &#39;Congratulations!&#39;)</pre><p>Örnekteki gibi call edilebilen bir function işimizi görecektir.</p><h3>Hadi başlayalım</h3><p>Öncelikle toast mesajın ihtiyaç duyacağı HTML elementleri oluşturan ve ekrana basan bir function yazalım.</p><pre><strong>toast-message.ts</strong></pre><pre>function printer(type = &#39;&#39;, message = &#39;&#39;, title = &#39;&#39;, duration = 3) {<br> const toastWrapper = document.createElement(&#39;div&#39;)<br> toastWrapper.classList.add(&#39;toast-wrapper&#39;)<br> toastWrapper.innerHTML = `<br> &lt;div class=&quot;toast ${type}&quot;&gt;<br> &lt;div class=&quot;toast__title&quot;&gt;${title}&lt;/div&gt;<br> &lt;div class=&quot;toast__message&quot;&gt;${message}&lt;/div&gt;<br> &lt;/div&gt;<br>`</pre><pre>toastWrapper.style.animationDuration = `${duration}s`</pre><pre>document.body.appendChild(toastWrapper)</pre><pre>setTimeout(() =&gt; {<br> toastWrapper.remove()<br> }, duration * 1000)<br>}</pre><p>Burada adı geçen elementlere CSS ile çeki düzen verelim.</p><pre><strong>toast.css</strong></pre><pre>.toast-wrapper {<br> position: fixed;<br> inset: 0;<br> top: 1em;<br> height: max-content;<br> display: grid;<br> place-content: center;<br> animation-name: toast-top;<br> animation-fill-mode: forwards;<br> font-size: 0.9em;<br>}</pre><pre>.toast {<br> background-color: #fff;<br> color: #222;<br> box-shadow: 0 0 10px 0 rgba(0, 0, 0, 0.2);<br> padding: 0.5em 1em;<br> border-radius: 0.5em;<br>}</pre><pre>.toast__title {<br> font-size: 1.2em;<br> font-weight: 600;<br> padding: 0.2em 0;<br>}</pre><p>Adı geçen <strong>toast-top</strong> animasyonunu oluşturalım.</p><pre><strong>toast.css</strong></pre><pre><a href=\"http://twitter.com/keyframes\">@keyframes</a> toast-top {<br> 0% {<br> transform: translateY(-100%);<br> }<br> 20% {<br> transform: translateY(0);<br> }<br> 80% {<br> transform: translateY(5%);<br> }<br> 90% {<br> transform: translateY(25%);<br> }<br> 100% {<br> transform: translateY(-200%);<br> }<br>}</pre><p>printer function’umuzu export edelim.</p><pre><strong>toast-message.ts</strong></pre><pre>const message = {<br> info: printer.bind(null, &#39;info&#39;),<br> success: printer.bind(null, &#39;success&#39;),<br> error: printer.bind(null, &#39;error&#39;),<br> warning: printer.bind(null, &#39;warning&#39;),<br>}</pre><pre>export default message</pre><p>Böylece dışarıda import ettikten sonra <strong>message.success</strong> gibi kullanabiliriz.</p><pre><strong>App.vue</strong></pre><pre>&lt;script setup&gt;<br>import message from &#39;./toast-message&#39;<br>&lt;/script&gt;</pre><pre>&lt;template&gt;<br> &lt;button @click=&quot;message.error(&#39;Error message&#39;)&quot;&gt;Error&lt;/button&gt;&lt;/template&gt;</pre><p><strong>GitHub Repo</strong>: <a href=\"https://github.com/gayret/toast-message-in-vuejs\">https://github.com/gayret/toast-message-in-vuejs</a></p><p><strong>Canlı Demo</strong>: <a href=\"https://toast-message.netlify.app/\">https://toast-message.netlify.app/</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a58495cf0f20\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " WebSocket, VueJS’te nasıl kullanılır? (Hazır paket kullanmadan) "
          },
          "link": "https://safa.medium.com/websocket-vuejste-nas%C4%B1l-kullan%C4%B1l%C4%B1r-haz%C4%B1r-paket-kullanmadan-adc7f29424f2?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/adc7f29424f2",
          "category": [
            {
              "__cdata": " javascript "
            },
            {
              "__cdata": " websocket "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Tue, 26 Jul 2022 11:13:21 GMT",
          "updated": "2022-07-26T11:13:21.746Z",
          "encoded": {
            "__cdata": " <h4>Web uygulama geliştirirken, kullanıcının sayfayı yenilemesini beklemeksizin yeni bilgilerden haberdar olmasını gerektiren senaryolarla karşılaşırız. Bu durumlarda başvurduğumuz yöntemlerin başında WebSocket gelir.</h4><p>WebSocket’in oluşturduğu iletişim kanalları sayesinde, kullanıcının herhangi bir istekte bulunmasını beklemeksizin, ekranına yeni bilgiyi gönderebiliriz. Yazışma (<em>WhatsApp, Messenger</em> vb.) uygulamalarının tamamı bu standart ile çalışır.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/668/1*H_yjD_g2PN5CnwDWTJTxAg.png\" /></figure><p><strong>Live Demo</strong>: <a href=\"https://websocket-vuejs.netlify.app/\">https://websocket-vuejs.netlify.app/</a></p><p><strong>GitHub Repo</strong>: <a href=\"https://github.com/gayret/websocket-vuejs\">https://github.com/gayret/websocket-vuejs</a></p><h3>Bir WebSocket kanalına nasıl bağlanılır?</h3><p>İhtiyaç duyacağımız tek şey <em>ws://</em> veya <em>wss://</em> protokolü ile başlayan bir url. Bu url, ilgili kanala doğrudan erişmemizi sağlayacak.</p><p>WebSocket bağlantısı kurmak için çeşitli hazır paketler var ancak mevcut senaryoda üçüncü parti bir pakete ihtiyacımız yok. JavaScript’in sağladığı WebSocket adlı reserved class, tüm aksiyonlarımızı karşılayabiliyor.</p><pre>const socket = new WebSocket(&#39;BURAYA WEBSOCKET URL&#39;)</pre><p>Bu tanımlamayı yaptıktan sonra gelen response’ları yakalamak için <strong>onmessage </strong>fonksiyonunu kullanırız.</p><pre>socket.onmessage = (event) =&gt; {<br> state.responses.push(event.data)<br>}</pre><p>Artık her yeni bilgi, state’imizdeki responses array’imize kaydedilir.</p><p>Mesaj göndermek için ise <strong>send </strong>fonksiyonunu kullanırız.</p><pre>socket.send(&#39;Gönderilecek mesaj&#39;)</pre><p>Bağlantıyı kapatmak için <strong>close </strong>fonksiyonunu kullanırız.</p><pre>socket.close()</pre><p>Bağlantının kapandığını yakalamak için <strong>onclose</strong>,</p><pre>socket.onclose = () =&gt; {<br> console.log(&#39;WebSocket closed&#39;)<br> state.socketConnected = false<br>}</pre><p>Yaşanabilecek hataları yakalamak için <strong>onerror </strong>fonksiyonunu kullanırız.</p><pre>socket.onerror = (error) =&gt; {<br> console.error(error)<br>}</pre><p>Hepsi bu kadar.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=adc7f29424f2\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " VueJS’te TailwindCSS ile Dark Mode ayarı nasıl yapılır "
          },
          "link": "https://safa.medium.com/vuejste-tailwindcss-ile-dark-mode-ayar%C4%B1-nas%C4%B1l-yap%C4%B1l%C4%B1r-e11008ef9672?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/e11008ef9672",
          "category": [
            {
              "__cdata": " dark-mode "
            },
            {
              "__cdata": " vuejs "
            },
            {
              "__cdata": " tailwind-css "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Thu, 07 Jul 2022 17:48:06 GMT",
          "updated": "2022-07-07T17:55:29.944Z",
          "encoded": {
            "__cdata": " <h4>Web uygulamalarına eklenen renk değiştirme opsiyonu son zamanlarda kullanıcı deneyimi (UX) standartlarının bir parçası haline geldi. Eğer projenizde Tailwind CSS Framework’ü kullanıyorsanız bunu ayarlamak çok kolay.</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/637/1*Ud17AFgFSqmsbw61e7BG5A.png\" /></figure><p><em>Bir VueJS projesine Tailwind CSS’in nasıl install edileceğini </em><a href=\"https://safa.medium.com/tailwind-css-vite-ile-olu%C5%9Fturulmu%C5%9F-vuejs-3e-nas%C4%B1l-kurulur-a92ee61c3ec5\"><em>önceki yazılarımda</em></a><em> açıklamıştım. Tailwind CSS ve GitHub Copilot’u birlikte kullanarak kendi UI standartlarınızı yapay zekadan yardım alarak nasıl kısa sürede tanımlayacağınızı da </em><a href=\"https://safa.medium.com/b%C4%B1rak%C4%B1n-ui%C4%B1-yapay-zeka-yazs%C4%B1n-df9afe7e75fe\"><em>yine başka bir yazımda</em></a><em> açıklamıştım.</em></p><p>Live Demo: <a href=\"https://tailwind-css-vuejs-dark-mode.netlify.app/\">https://tailwind-css-vuejs-dark-mode.netlify.app/</a></p><p>GitHub Repo: <a href=\"https://github.com/gayret/tailwind-css-vuejs-dark-mode\">https://github.com/gayret/tailwind-css-vuejs-dark-mode</a></p><h3>Hadi başlayalım</h3><p>Bilindiği üzere Tailwind CSS, reserved class’larla UI tasarımı yönetmemizi sağlayan bir CSS Framework. Dolayısıyla Dark Mode yönetimini de yine class’larla yapacağız.</p><p>Öncelikle Dark Mode yönetimini class ile yapacağımızı tailwind.config.js içerisinde belirtelim.</p><pre><strong>tailwind.config.js</strong></pre><pre>module.exports = {<br> darkMode: &#39;class&#39;,<br>}</pre><p>Dark Mode’a geçildiğindebody arka planının tamamına koyu bir gri rengi atamak istediğimizde aşağıdaki gibi uygulayabiliriz.</p><pre><strong>index.html</strong></pre><pre>&lt;body class=&quot;bg-white dark:bg-gray-800&quot;&gt;<br> &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br> &lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt;<br>&lt;/body&gt;</pre><p>Böylece projemizin varsayılan arka plan rengini white olarak atadık. Dark Mode’a geçildikten sonraki arka plan rengini ise gray-800 diye kodlanan koyu bir gri yaptık.</p><p>Ayarladığımız bu geçişi görmek için yapmamız gereken tek şey, geçişi tetiklemek. Bunun için toggleTheme adlı bir method oluşturalım.</p><pre>const toggleTheme = () =&gt; {<br> state.theme = state.theme === &#39;light&#39; ? &#39;dark&#39; : &#39;light&#39;<br> if (state.theme === &#39;dark&#39;) {<br> document.documentElement.classList.add(&#39;dark&#39;)<br> } else {<br> document.documentElement.classList.remove(&#39;dark&#39;)<br> }<br>}</pre><p>İsteğe bağlı olarak theme bilgisini localStorage’da da tutabiliriz, bunu yaparsak kullanıcının sonraki oturumunda Theme Mode bilgisi hatırlanır ve kullanıcı bıraktığı gibi bulur.</p><p>Bu method’u bir button ile tetikleyebiliriz.</p><pre>&lt;button <a href=\"http://twitter.com/click\">@click</a>=&quot;toggleTheme&quot;&gt;<br> {{ state.theme === &#39;light&#39; ? &#39;Dark&#39; : &#39;Light&#39; }}<br>&lt;/button&gt;</pre><p><strong>Hepsi bu kadar.</strong> Artık dark: ön ekiyle birlikte ekleyeceğiniz tüm Tailwind CSS özellikleri, kullanıcı Dark Mode’a geçtiğinde aktif olacak.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e11008ef9672\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " Parent Component ile Child Component arasında v-model ilişkisi kurmak "
          },
          "link": "https://safa.medium.com/parent-component-ile-child-component-aras%C4%B1nda-v-model-ili%C5%9Fkisi-kurmak-859db2ee7d79?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/859db2ee7d79",
          "category": [
            {
              "__cdata": " two-way-data-binding "
            },
            {
              "__cdata": " vuejs "
            },
            {
              "__cdata": " custom-component "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Sat, 02 Jul 2022 13:34:36 GMT",
          "updated": "2022-07-02T13:34:36.354Z",
          "encoded": {
            "__cdata": " <h4>VueJS’te componentler arasında iletişim kurmanın onlarca yolu var. v-model bu yollardan oldukça kullanışlı olanı. HTML inputlardaki bilgileri reaktif bir şekilde yakalamak için v-model kullanarak ‘two way binding’ kurarız. Peki HTML input dışında kendi oluşturduğumuz componentle de v-model ile iletişim kurabilir miyiz, evet.</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/900/1*zHeuV1WJzgfTCbOesqEDXA.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/208/1*a0wjUB-cywfCIsmTmgC5Rg.png\" /></figure><p>Senaryo gereği, tüm HTML inputları sarmalayan bir Child Componente ihtiyacımız olsun. Örnek olması amacıyla Parent’ta input kullanacağımız zaman, klasik HTML input kullanmak yerine kendi oluşturduğumuz &lt;child /&gt; elementini kullanmayı arzu ediyoruz.</p><p><strong>Canlı demo</strong>: <a href=\"https://vue-parent-child-component-vmodel.netlify.app/\">https://vue-parent-child-component-vmodel.netlify.app/</a></p><p><strong>GitHub repo</strong>: <a href=\"https://github.com/gayret/vue-parent-child-component-vmodel\">https://github.com/gayret/vue-parent-child-component-vmodel</a></p><h3>Hadi başlayalım</h3><p>Öncelikle <strong>components </strong>klasörü altında <strong>Child.vue</strong> adlı bir dosya oluşturalım.</p><p>VueJS, parent componentle iletişim kuracak child componentin modelValue adında bir prop bekliyor olmasını istiyor. <strong>modelValue </strong>adlı prop üst componentte v-model ile bağlanmış state ile doğrudan ilişki kurabiliyor.</p><pre><strong>Child.vue</strong></pre><pre>&lt;script setup&gt;<br> const props = defineProps({<br> modelValue: String,<br> })<br>&lt;/script&gt;</pre><p>Yakaladığımız bu prop ile <strong>Child.vue</strong> içerisinde oluşturacağımız reaktif state’i ilişkilendirelim.</p><pre>const value = ref(props.modelValue)</pre><p>value adlı state’imizi template içerisindeki bir input’la two way binding yapalım.</p><pre>&lt;template&gt;<br> &lt;input v-model=&quot;value&quot; /&gt;<br>&lt;/template&gt;</pre><p>Böylece Child.vue içerisindeki input, modelValue adlı prop’taki bilgiyle eşitlendi. Ancak henüz bu input içerisindeki bilginin değişimini Parent Component’e iletmiyoruz. Input’taki her değişimi takip etmek için VueJS’in watch reserved fonksiyonunu kullanabileceğimiz gibi, input’a @input eventListener’ı da ekleyerek aynı sonuca ulaşabiliriz. Bu örnekte watch ile yapıyorum.</p><p>Input’taki her değişimi Parent’a dağıtmanın tek yolu emit etmek. Bunun için emit fonksiyonunu define edelim. update:modelValue Parent Component tarafından otomatik olarak yakalanır.</p><pre>const emit = defineEmits([&#39;update:modelValue&#39;])</pre><p>Artık watch ile her değişimi Parent Component’e dağıtabiliriz.</p><pre>watch(value, (newVal) =&gt; {<br> emit(&#39;update:modelValue&#39;, newVal)<br>})</pre><p><strong>Hepsi bu kadar</strong>, oluşturduğumuz Child adlı Component’i herhangi bir Component içerisine import edip v-model ile iletişim kurdurabiliriz.</p><pre><strong>Parent.vue</strong></pre><pre>&lt;child v-model=&quot;someThing&quot; /&gt;</pre><p><strong>GitHub repo</strong>: <a href=\"https://github.com/gayret/vue-parent-child-component-vmodel\">https://github.com/gayret/vue-parent-child-component-vmodel</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=859db2ee7d79\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " VueJS’te sürükle bırak yapmak (Hazır paket kullanmadan) "
          },
          "link": "https://safa.medium.com/vuejste-s%C3%BCr%C3%BCkle-b%C4%B1rak-yapmak-haz%C4%B1r-paket-kullanmadan-d300770dfc56?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/d300770dfc56",
          "category": [
            {
              "__cdata": " html "
            },
            {
              "__cdata": " javascript "
            },
            {
              "__cdata": " drag-and-drop "
            },
            {
              "__cdata": " vuejs "
            },
            {
              "__cdata": " pure "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Wed, 15 Jun 2022 06:26:55 GMT",
          "updated": "2022-06-15T06:26:55.624Z",
          "encoded": {
            "__cdata": " <h4>“Amerika’yı yeniden keşfetmenin alemi yok, hazır bir paket varsa kullan konuyu kapat” ezberinin haklılık yanı elbette var ancak kullandığınız paket sayısı arttıkça projenin sağlığı zarar görebiliyor. Bu nedenle gelişen teknolojiyi takip edip, paket kullanmadan yapılabilecek işlemleri kendimiz yapmalıyız.</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ER0Fybbx0bHrEsKzm1ZSvg.png\" /></figure><p><strong>GitHub Repo: </strong><a href=\"https://github.com/gayret/vue-drag-and-drop\">https://github.com/gayret/vue-drag-and-drop</a></p><p><strong>Canlı demo:</strong> <a href=\"https://vue-drag-and-drop.netlify.app/\">https://vue-drag-and-drop.netlify.app</a></p><p>HTML ve JavaScript kullanarak dakikalar içerisinde sürükle bırak işlemi yaptırabilirsiniz.</p><h3>Hadi basit bir Todo geliştirelim</h3><p>Öncelikle reaktif bir array oluşturalım.</p><pre>const todos = reactive([<br> {<br> id: 1,<br> title: &#39;Watch The Matrix&#39;,<br> completed: false,<br> },<br> {<br> id: 2,<br> title: &#39;Write an essay about Vue&#39;,<br> completed: false,<br> },<br> {<br> id: 3,<br> title: &#39;Learn NextJS&#39;,<br> completed: true,<br> },<br>])</pre><p>Ardından bu array’daki bilgileri <strong>computed</strong> ile filtreleyip çekelim.</p><pre>const thingToDo = computed(() =&gt; {<br> return todos.filter((item) =&gt; !item.completed)<br>})</pre><pre>const completed = computed(() =&gt; {<br> return todos.filter((item) =&gt; item.completed)<br>})</pre><p>Sonrasında <strong>Vue Template</strong> bölümünde bir v-for döngüsü yaratalım. Böylece <strong>yapılacaklar listesini</strong> ortaya koyalım.</p><p>Listedeki item’lara draggable=’true’ attribute ekleyerek sürüklenebilir olmasını sağlayın.</p><pre>&lt;ul v-if=&quot;thingToDo.length &gt; 0&quot;&gt;<br> &lt;li<br> v-for=&quot;(todo, index) in thingToDo&quot;<br> :key=&quot;todo.id&quot;<br> <strong>draggable=&quot;true&quot;</strong><br> <a href=\"http://twitter.com/dragstart\">@dragstart</a>=&quot;onDrag($event, todo.id)&quot;&gt;<br> &lt;label&gt;<br> &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.completed&quot; /&gt;<br> {{ todo.title }}<br> &lt;/label&gt;<br> &lt;/li&gt;<br>&lt;/ul&gt;</pre><p>Listedeki item’lardan hangisinin sürüklenmeye başladığını bilmemiz gerekiyor. Bunun için @dragstart event’ı gerçekleştiğinde tetiklenmek üzere onDrag methodumuzu yazalım. Bu methoda $event ve todo bilgilerini gönderelim.</p><pre>const onDrag = (event, id) =&gt; {<br> event.dataTransfer.setData(&#39;itemIndex&#39;, id)<br>}</pre><p>onDrag methodumuz şunu yapar, Event’in dataTransfer alanına, daha sonra itemIndex key’i ile get edilebilecek şekilde set eder. Yani o an sürüklemeye başlanan item’ın Id bilgisini sanal bir state’e yazar.</p><p>Artık kullanıcının hangi item’ı sürüklediğini biliyoruz.</p><h3>Kullanıcının sürüklediği item’ı bırakabileceği bir alan yaratalım</h3><p>Sürüklenen item’ın bırakılmasını istediğimiz HTML element’e şu iki attribute’ü ekleyin. @dragenter.prevent @dragover.prevent</p><p>Ardından aynı HTML element’in @drop event’ı gerçekleştiğinde tetiklenmek üzere onDrop methodumuzu yazalım.</p><pre>const onDrop = (event) =&gt; {<br> const itemId = event.dataTransfer.getData(&#39;itemId&#39;)<br> const item = todos.find((item) =&gt; item.id == itemId)<br> const itemIndex = todos.indexOf(item)<br> todos[itemIndex].completed = !todos[itemIndex].completed<br>}</pre><p>Bu method ile, az önce set ettiğimiz Id bilgisine erişiyoruz, sonra Array’deki index konumunu öğreniyoruz. Güncellemek istediğimiz (completed) bilgisini değiştiriyoruz.</p><p>Hepsi bu kadar.</p><p>Hiçbir hazır paket kullanmadan sürükle bırakma işlemi yaptık.</p><p><em>Bu örnekte sürüklenen item önceki bulunduğu yerden silinip, sadece yeni konumunda bulunacak. Her iki yerde de bulunmasını istersek, bunu item’in state bilgisini mutate etmeden yapmalıyız. Belki ilerde bununla ilgili bir örnek ekleyerek bu yazıyı güncellerim.</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d300770dfc56\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " Bırakın UI’ı yapay zeka yazsın "
          },
          "link": "https://safa.medium.com/b%C4%B1rak%C4%B1n-ui%C4%B1-yapay-zeka-yazs%C4%B1n-df9afe7e75fe?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/df9afe7e75fe",
          "category": [
            {
              "__cdata": " artificial-intelligence "
            },
            {
              "__cdata": " ui "
            },
            {
              "__cdata": " github-copilot "
            },
            {
              "__cdata": " tailwind-css "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Sun, 05 Jun 2022 11:23:02 GMT",
          "updated": "2022-06-06T04:16:04.529Z",
          "encoded": {
            "__cdata": " <h4>Teknolojinin durdurulamaz gelişimine ayak uyduran developer’lar development sürecini hem kısaltıp hem de daha keyifli hale getirebilir.</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/884/1*ivrDYtYwedwnk-R6IN8h9Q.png\" /></figure><p>GitHub Copilot ve Tailwind CSS birlikte verimli bir şekilde kullanıldığında frontend developer’ın angarya işleri otomatikleşiyor.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/358/1*mQufltEKj_23TutrEYierQ.png\" /></figure><p>Resimdeki <strong>Increment</strong> buttonunu elde etmek için aşağıdaki kodu Tailwind CSS base’i import ettiğimiz yere ekleyelim. (Veya hayalinizdeki button tasarımını Tailwind CSS reserved class’ları ile hazırlayın)</p><pre><strong>index.css</strong></pre><pre><a href=\"http://twitter.com/layer\">@layer</a> components {<br> .btn-primary {<br> <a href=\"http://twitter.com/apply\">@apply</a> py-2 px-4 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75;<br> }<br>}</pre><p>Böylece projemizde <strong>btn-primary</strong> class’ı taşıyan elementlerin style’ını yazmış olduk. Artık sahneyi GitHub Copilot’a bırakabiliriz.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2F8X29LhZGMtw%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D8X29LhZGMtw&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2F8X29LhZGMtw%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/a5cd37fd789ba5e82fe36522e8f92a5e/href\">https://medium.com/media/a5cd37fd789ba5e82fe36522e8f92a5e/href</a></iframe><p>Videoda görüldüğü üzere <strong>btn-primary</strong> dışındaki kodları GitHub Copilot otomatikman yazıyor.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/309/1*4FjVUGLkj4IGgMkLnJL9gg.png\" /></figure><p>Bu senaryoyu sadece button tasarlamak için değil, aklınıza gelen tüm tekrar eden işlemler için kullanabilirsiniz.</p><p>Belki <strong>GitHub Copilot</strong> yakın gelecekte ücretli ve ulaşılması zor bir araç haline gelebilir. Böyle bir durum gerçekleşmeden önce tecrübe etmenizde fayda var.</p><p><strong>GitHub Repo</strong>: <a href=\"https://github.com/gayret/tailwind-css-vuejs\">https://github.com/gayret/tailwind-css-vuejs</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=df9afe7e75fe\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " Tailwind CSS, Vite ile oluşturulmuş VueJS 3'e nasıl kurulur? "
          },
          "link": "https://safa.medium.com/tailwind-css-vite-ile-olu%C5%9Fturulmu%C5%9F-vuejs-3e-nas%C4%B1l-kurulur-a92ee61c3ec5?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/a92ee61c3ec5",
          "category": [
            {
              "__cdata": " tailwind-css "
            },
            {
              "__cdata": " vuejs "
            },
            {
              "__cdata": " css "
            },
            {
              "__cdata": " vitejs "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Sun, 29 May 2022 11:02:33 GMT",
          "updated": "2022-05-29T11:15:30.691Z",
          "encoded": {
            "__cdata": " <h4>Yazılım geliştirmede kararlılık (stabilite) ve hız çok önemlidir. Bundan beş yıl önce Frontend geliştirmek zaman alan bir deneyimdi. Sadece development ortamı ve hot reload imkanı oluştururken bile GulpJS gibi araçlara mahkumduk, optimizasyonu zahmetliydi ve tutarsızlıklarla karşılaşırdık. Gelişen teknolojiyle (ve framework’lerle ) artık hot reload; üzerinde hiçbir kontrolümüz olmayan, otomatikman kendini gerçekleştiren default bir özellik.</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/712/1*3LVaHw2SN2wh5JhwDZHHyA.png\" /></figure><p>Her zaman gelişimi sempatik bulamayabiliriz, hatta genellikle her yeni ‘icada’ bir direnç gösteririz, ancak önünde sonunda bu gelişimlerden faydalanırız ve övmeye başlarız. Frontend topluluğu için <strong>Tailwind CSS</strong> övme zamanı geldi. Son zamanlarda hakkında çokça yazılar yazılıyor, övgü dolu video içerikler yayınlanıyor.</p><h3>Nedir bu Tailwind CSS?</h3><p>Tailwind bir CSS framework’üdür. Her frontend developer’ın kendince küçük çaplı yarattığı bir<em> class merkezli style yönetimine</em> benzer. Örneğin, justify-center adında bir global class tanımlarsınız. İçerisinde display: flex; justify-content: center komutları vardır. Ne zaman bir nesneye bu komutları uygulamak isterseniz justify-center class’ı atayıp geçersiniz. Tailwind CSS bu prensiple çalışır. Ama çok daha gelişmiştir.</p><h3>Tailwind CSS’e hazır mıyım?</h3><p>Tailwind CSS kullanan Frontend Developer’ların ortak bir önerisi var. Pure <strong>CSS</strong>’te belli bir seviyeye gelmeden Tailwind CSS gibi framework’lere bulaşmayın. Aksi takdirde Tailwind CSS’ten umduğunuz performansı alamazsınız ve Pure CSS’te ciddi bir körelme görülebilir.</p><p>Flexbox ve CSS Grid konseptlerini biliyorsanız ve <em>Media Query </em>kullanarak responsive tasarımlar yapabiliyorsanız Tailwind CSS’e hazırsınız diyebiliriz.</p><h3>VueJS 3&#39;e nasıl kurulur</h3><ul><li><strong>Vite </strong>ile VueJS projesi yaratın</li><li>Tailwind CSS kurun</li></ul><pre>npm install -D tailwindcss postcss autoprefixer<br>npx tailwindcss init -p</pre><ul><li>tailwind.config.js Dosyası içerisindeki content array’ini aşağıdaki komutla değiştirin.</li></ul><pre>content: [<br> &quot;./index.html&quot;,<br> &quot;./src/**/*.{vue,js,ts,jsx,tsx}&quot;,<br>],</pre><ul><li>src içerisine index.css adlı CSS dosyası yaratın, içerisine aşağıdaki komutları yapıştırın.</li></ul><pre><a href=\"http://twitter.com/tailwind\">@tailwind</a> base;<br><a href=\"http://twitter.com/tailwind\">@tailwind</a> components;<br><a href=\"http://twitter.com/tailwind\">@tailwind</a> utilities;</pre><ul><li>main.js içerisinde index.css’i import edin.</li></ul><p>Artık projenizin herhangi bir yerinde Tailwind CSS class’larını kullanabilirsiniz.</p><p><strong>GitHub Repo</strong><br><a href=\"https://github.com/gayret/tailwind-css-vuejs\">https://github.com/gayret/tailwind-css-vuejs</a></p><p><strong>Yararlandığım kaynaklar</strong></p><ul><li><a href=\"https://tailwindcss.com/docs/guides/vite\">https://tailwindcss.com/docs/guides/vite</a></li></ul><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a92ee61c3ec5\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        }
      ]
    }
  }
}
