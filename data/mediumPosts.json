{
  "rss": {
    "channel": {
      "title": {
        "__cdata": " Stories by Safa Gayret on Medium "
      },
      "description": {
        "__cdata": " Stories by Safa Gayret on Medium "
      },
      "link": ["https://medium.com/@safa?source=rss-3ede4c648e44------2", "", ""],
      "image": {
        "url": "https://cdn-images-1.medium.com/fit/c/150/150/1*j_Ek9T7Vk87uS0UgvjBufQ.jpeg",
        "title": "Stories by Safa Gayret on Medium",
        "link": "https://medium.com/@safa?source=rss-3ede4c648e44------2"
      },
      "generator": "Medium",
      "lastBuildDate": "Wed, 07 Jun 2023 08:37:10 GMT",
      "webMaster": {
        "__cdata": " yourfriends@medium.com "
      },
      "item": [
        {
          "title": {
            "__cdata": " Bazen çalışmak içinden gelmez "
          },
          "link": "https://safa.medium.com/bazen-%C3%A7al%C4%B1%C5%9Fmak-i%C3%A7inden-gelmez-fb6b037cb59d?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/fb6b037cb59d",
          "category": [
            {
              "__cdata": " motivation "
            },
            {
              "__cdata": " work "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Mon, 15 May 2023 13:09:39 GMT",
          "updated": "2023-05-15T13:09:39.430Z",
          "encoded": {
            "__cdata": " <h4>Fiziksel olarak bir şeyleri bir yerlerden alıp başka bir yerlere bırakmak gibi bir iş yapmıyorsanız, yani fiziksel olarak emeğinizle para kazanmıyorsanız, o işi asgari seviyede yerine getirebilmeniz için ruh halinizin çalışmaya uygun olması gerekir.</h4><p>Yazılımda motivasyon o kadar önemlidir ki kafanızda ileri seviye yazılım tecrübesi, tanrı vergisi bir öngörü kabiliyeti de taşısanız, kod yazma sürecini çalışmak olarak görmeyecek kadar keyifli de bulsanız, motivasyonunuz yoksa yazdığınız kod hiçbir şeye hizmet etmez.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/626/0*CpL7Hi3_4G7w_xA_.jpg\" /><figcaption>Fotoğraf kaynağı: <a href=\"https://www.freepik.com/free-photo/tired-man-sitting-his-home-desk_11785932.htm\">Freepik</a></figcaption></figure><p>Elbette motivasyon her iş sahasında ve herkese gereklidir ancak yazılım gibi son derece soyut bir iş üzerindeyseniz motivasyon en çok size gerekir.</p><h3>Safa Dev on Twitter: &quot;İyi kod yazmak için bir developer&#39;ın ihtiyaç duyduğu ilk şey motivasyon. Sonra bilgisayar falan... / Twitter&quot;</h3><p>İyi kod yazmak için bir developer&#39;ın ihtiyaç duyduğu ilk şey motivasyon. Sonra bilgisayar falan...</p><h3>Yar bana bir motivasyon medet</h3><p>Ekonomik gelir, ideal çalışma ortamı gibi asgari şartlar sağlandıktan sonra ihtiyaç duyulan motivasyona sahip olmak için herkesin izlemesi gereken yol farklıdır. Kimi mesaiden sonra gideceği konserin heyecanıyla motive olur, kimi yeni bir şey öğrenmekle. Eğer yeni bir şey öğrenmekle motive oluyorsanız iyi haber, sürdürülebilir bir motivasyon kaynağınız var demektir.</p><p>Kendinizi geliştirerek, yeni şeyler öğrenerek motive oluyorsanız, bulunduğunuz ekip ve üzerinde çalıştığınız projeler de bu yeni öğrendiğiniz şeyleri deneyimleme fırsatı sunuyorsa, sizden şanslısı yok. Pazartesiler sizin için “sendrom” değildir.</p><h3>Olmuyor olmuyor</h3><p>Yine de… her şeye rağmen, çok kolay motive oluyor olsanız bile insan bazen tüm motivasyonunu yitirir, sıcak çikolata içip pencereden dışarıya bakmak ister. Koltukta oturmaktan sıkılır, ayakta durmaktan sıkılır… Böyle zamanlarda size atanan görevleri yerine getirmeye çalışmak kendinize yaptığınız bir işkencedir. Ve maalesef bu işkence, sizi içerisinde bulunduğunuz motivasyonsuzluğa daha uzun süre hapsedecektir.</p><p>Olmuyorsa, motive olamıyorsanız, normalde bir saatinizi alacak göreve saatlerdir bakıp bakıp “hoff” çekiyorsanız… durun. O görev beklesin, motivasyonunuzu toplayıncaya kadar kalkın o koltuktan ve o işi odağınızdan çıkarın, farklı şeylerle meşgul olun. İnanın birazcık motivasyon toplayıp döndüğünüzde tüm sorunları çatır çutur çözeceksiniz :)</p><p>Eğer bir gün ekip arkadaşlarıma izin verebilecek bir pozisyonda görev yaparsam,<em> “İçinizden çalışmak gelmediğinde çalışmayın arkadaşlar”</em> derim.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fb6b037cb59d\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " Plastik ördeğin yazılımcının hayatındaki yeri ve önemi "
          },
          "link": "https://safa.medium.com/plastik-%C3%B6rde%C4%9Fin-yaz%C4%B1l%C4%B1mc%C4%B1n%C4%B1n-hayat%C4%B1ndaki-yeri-ve-%C3%B6nemi-51ebaee63ac?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/51ebaee63ac",
          "category": [
            {
              "__cdata": " error "
            },
            {
              "__cdata": " software-development "
            },
            {
              "__cdata": " debugging "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Mon, 24 Apr 2023 15:49:16 GMT",
          "updated": "2023-04-24T15:49:16.646Z",
          "encoded": {
            "__cdata": " <h4>Yazılımda hata ayıklamanın onlarca yolu var. Gelin özellikle mesleğe yeni başlandığında kendiliğinden keşfedilen ama adı pek bilinmeyen bir yöntem olan Rubber duck debuggering’i tanıyalım.</h4><p>Bir geliştirme yaparken genellikle her şeyin doğru gittiğine inanır ve büyük bir özgüvenle yazdığımız satırların çalışmasını bekleriz. Ama yazdığımız kodlar her zaman ilk seferde çalışmayabilir. Daha kötüsü anlaşılır bir hata mesajıyla da karşılaşmayabiliriz. Bu sinir bozucu durumdan kurtulmak için kodumuzu defalarca okuruz, küçük düzeltmeler yaparız ve “Artık çalışır” deriz, ama yine çalışmaz :) Özellikle mesleğe yeni başlandığında, kendini kanıtlama baskısı altında yepyeni evrenlere paldır küldür dalındığında çok sık yaşanır bu.</p><h3>“Çalışmaması için hiçbir neden yok!?”</h3><p>Çaresiz bir şekilde üstünkörü kodu inceleyip tekrar çalıştırmayı deneriz, deneriz, deneriz. “Ooooff! çalışmıyor anasını satim. Babamın kendi küçük çiftliğimizi kuralım, toprakla doğayla iç içe olalım teklifi o kadar da kötü değildi ya, başlarım teknolojiye!” :) Tüm bu öfke patlamaları içerisinde paşa paşa gidip şirketteki tecrübeli birine danışılır.</p><p><strong>Junior</strong>: Senior Hanım veya Bey, bir sorun var ama aslında yok, çalışması lazım ama çalışmıyor.</p><p><strong>Senior</strong>: Tamam, hadi beraber bakalım</p><p>Junior’un masasına geçilir. Junior arkadaş ilgili kodu açar, o kodların ne yapması gerektiğini <strong>satır satır</strong> anlatır. Bu anlatım sırasında Senior sadece arada bir başını sallar ve Junior’un anlatmaya devam etmesini sağlayacak şeyler söyler.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/500/0*xALPn1WaErP4k9On.jpg\" /><figcaption><a href=\"https://en.wikipedia.org/wiki/Rubber_duck_debugging\">https://en.wikipedia.org/wiki/Rubber_duck_debugging</a></figcaption></figure><p>Junior büyük bir heyecan ve küçücük öfkeyle farkında olmadan debugging yapıyordur. Anlatır, anlatır, anlatır sonunda kendi kendine hatasını bulur.</p><p><strong>Junior</strong>: Aaa çok basit bir hata yapmışım, x değişkenine bu scope’da erişemem ki…</p><p>Senior, hatayı bulmaya yönelik hiçbir ipucu vermemiştir veya yönlendirmemiştir. Junior anlatırken kendi kendine hatasını bulur.</p><p>Bu senaryoyu hem Junior iken hem de şimdilerde, bazen anlatan bazen dinleyen tarafta tekrar tekrar deneyimliyorum :) Senaryodaki işlevsiz Senior’u plastik sarı bir ördekle değiştirdiğimizi hayal edelim. “Bak ördek kardeş, bu satırda şunun gerçekleşmesini bekliyorum, sonraki satırda ise şunun gerçekleşmesini bekliyorum…”</p><p>Bu yolu izleyerek, bazen sesli bazen sessizce çözüme ulaşabiliyoruz. İşte bu yolun adı “Rubber duck debuggering”</p><p>Ördeğinizi yanınızdan ayırmayın :)</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=51ebaee63ac\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " Biz neden böyle sayfalar tasarlayamıyoruz? "
          },
          "link": "https://safa.medium.com/biz-neden-b%C3%B6yle-sayfalar-tasarlayam%C4%B1yoruz-79b5366e91e1?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/79b5366e91e1",
          "category": [
            {
              "__cdata": " design "
            },
            {
              "__cdata": " awards "
            },
            {
              "__cdata": " quality "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Wed, 19 Apr 2023 15:17:32 GMT",
          "updated": "2023-04-19T18:12:00.276Z",
          "encoded": {
            "__cdata": " <h4>Bazen webde; elindeki veriyi en doğru şekilde kullanan ve tasarım açısından büyüleyen örneklere rastlıyoruz. Az önce bir yenisine daha rastladım.</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*EiI3tH1LhKMnYjEN7qncaw.png\" /><figcaption><a href=\"https://audemarspiguet.com/com/en/watch/code-1159-universelle.html\">https://audemarspiguet.com/com/en/watch/code-1159-universelle.html</a></figcaption></figure><p>İnsana, aklında hiç yokken kol saati satabilecek bir tasarım. <a href=\"https://www.cssdesignawards.com/\">CSS Design Awards</a> tarafından ödül almış.</p><p>Peki böyle tasarımlar neden ülkemizden çıkmıyor? Bakın ülkemizdeki developar’lardan demiyorum, ülkemizden diyorum. Bunun birçok nedeni var, gelin bazı popüler yanıtları masaya yatıralım.</p><h3>Çünkü bizde her şey “acil” ve “zaman yok”</h3><p>Tamamı Türklerden oluşan bir yazılım ekibindeyseniz toplantılarda duyacağınız teslim tarihleri genellikle önünüzdeki birkaç günden biridir. İşinizi iyi ve özenli yapmaktan daha öncelikli bir göreviniz vardır, “yetiştirmek”</p><p>Tasarım, ince işçilik, zeka, fonksiyonellik… “yetiştirmek” gerekliliğinin arkasında kalır.</p><h3>Çünkü gerekli motivasyon yok</h3><p>Kim ne derse desin, meslek bağımsız, (doktor, öğretmen bile olsa) bir çalışanın en büyük motivasyon kaynağı aldığı ücrettir. <strong>Kira ve kredi taksiti düşünen bir çalışanın, emeğiyle ortaya bir sanat eseri koymaya mecali yoktur.</strong></p><p>Ülkemizde (meslek bağımsız) çalışanlar, öğrenciden hallice bir hayat sürerler. Hatta açıkça söyleyebilirim ben öğrenciyken daha zengindim :) o günlerden bugünlere ekonomimiz o kadar kötüye gitti ki... Ben öğrenciyken sinema, konser, tiyatro vb. etkinlikler lüks değildi.</p><h3>Çünkü müşteriden böyle bir talep yok</h3><p>Yukarıdaki nedenlerle açıklayabileceğimiz üzere, ülkemizde bu denli ince işçilikli kol saatleri üreten bir marka yok. İşini o kadar iyi yapmayan bir saat markasının bu kadar yaratıcı web sayfalar tasarlatacak vizyonu da yok, beklentisi de yok.</p><p>“Müşterim ürünlerimi bulabilsin, satın alım gerçekleştirebilsin yeter.” Bu vizyondaki bir müşteriye uçuk kaçık yenilikçi bir tasarımı öneremezsiniz, onaylatamazsınız.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=79b5366e91e1\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " Form Builder nasıl yapılır (VueJS ile) "
          },
          "link": "https://safa.medium.com/form-builder-nas%C4%B1l-yap%C4%B1l%C4%B1r-vuejs-ile-87527be943bd?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/87527be943bd",
          "category": [
            {
              "__cdata": " jotform "
            },
            {
              "__cdata": " vuejs "
            },
            {
              "__cdata": " formbuilder "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Sun, 09 Apr 2023 12:14:14 GMT",
          "updated": "2023-04-09T17:16:30.241Z",
          "encoded": {
            "__cdata": " <p>VueJS ile (<a href=\"https://www.jotform.com\"><strong>Jotform</strong></a><strong> </strong>benzeri) form builder yapmanız gerektiğinde maalesef internette pek kaynak bulamayacaksınız, madem kaynak yok o halde beraber oluşturalım.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*T9YMOmuE3k_x3goJjmSOoQ.png\" /><figcaption>[Görsel 1] Bittiği zaman böyle görünecek, <a href=\"https://form-builder-vuejs.netlify.app/\">https://form-builder-vuejs.netlify.app</a></figcaption></figure><p>Bir form builder dört temel component’ten bir araya gelir <strong>Toolbox</strong>, <strong>Designer</strong>, <strong>Preview</strong>, <strong>Properties</strong>. Elbette ihtiyaca göre anlamlı en küçük yapıları component’leştirebiliriz. Ben bu complex yapıyı en kolay anlatabileceğim şekilde kodlamayı seçtim.</p><pre> &quot;dependencies&quot;: {<br> &quot;remixicon&quot;: &quot;^2.5.0&quot;,<br> &quot;vue&quot;: &quot;^3.2.45&quot;<br> },</pre><p>Bağımlılık olarak yalnızca icon paketi olan <strong>remixicon </strong>kullandım. Global state management’e dahi başvurmadım.</p><p>(bkz: <a href=\"https://safa.medium.com/vuex-olmasa-da-olur-mu-cecae3085bba\">Vuex olmasa da olur mu?</a>)</p><h3>Hadi başlayalım</h3><p>Az sonra oluşturacağımız temel component’leri, <strong>App.vue</strong> içerisinde kullanacağız.</p><pre>&lt;div class=&quot;form-builder&quot;&gt;<br> &lt;div class=&quot;form-builder-header&quot;&gt;<br> &lt;h1&gt;Form Builder&lt;/h1&gt;<br> &lt;div class=&quot;btn-group&quot;&gt;<br> &lt;button @click=&quot;toggleMode&quot;&gt;{{ mode === &#39;designer&#39; ? &#39;Preview&#39; : &#39;Designer&#39; }}&lt;/button&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br> &lt;div class=&quot;form-builder-wrapper&quot;&gt;<br> &lt;Toolbox /&gt;<br> &lt;div class=&quot;main&quot;&gt;<br> &lt;Designer v-if=&quot;mode === &#39;designer&#39;&quot; v-model=&quot;formBuilderJSON&quot; @on-select-field=&quot;changeSelectedField&quot; /&gt;<br> &lt;Preview v-else v-model=&quot;formBuilderJSON&quot; /&gt;<br> &lt;/div&gt;<br> &lt;Properties v-model=&quot;selectedField&quot; /&gt;<br> &lt;/div&gt;<br>&lt;/div&gt;</pre><p><a href=\"https://github.com/gayret/form-builder-vuejs/blob/main/src/components/Toolbox.vue\"><strong>Toolbox.vue</strong></a> component’i <em>Görsel 1</em>&#39;de solda görünen araç kutusundan ibaret, bu kutunun kabiliyetleri şunlar olmalı. Form oluştururken kullanabileceğimiz tüm field türlerini listelemeli. Bu fieldlar kullanıcı tarafından sürükleme yoluyla alınmak istendiğinde <strong>event.dataTransfer</strong>’e set etmeli.</p><p>Tamam, bu durumda içerisinde <strong>onDrag </strong>fonksiyonu olan bir component işimizi görecektir.</p><pre>&lt;script setup&gt;<br>import tools from &#39;../composables/tools&#39;<br>import Icon from &#39;./Icon.vue&#39;<br><br>const onDrag = (e, tool) =&gt; {<br> e.dataTransfer.setData(&#39;text/plain&#39;, JSON.stringify(tool))<br>}<br>&lt;/script&gt;<br><br>&lt;template&gt;<br> &lt;div class=&quot;card toolbox&quot;&gt;<br> &lt;h4&gt;Toolbox&lt;/h4&gt;<br> &lt;ul&gt;<br> &lt;li v-for=&quot;tool in tools&quot; :key=&quot;tool.title&quot; draggable=&quot;true&quot; @dragstart=&quot;onDrag($event, tool)&quot;&gt;<br> &lt;span class=&quot;icon&quot;&gt;<br> &lt;Icon :name=&quot;tool.icon&quot; /&gt;<br> &lt;/span&gt;<br> &lt;span class=&quot;title&quot;&gt;<br> {{ tool.title }}<br> &lt;/span&gt;<br> &lt;/li&gt;<br> &lt;/ul&gt;<br> &lt;/div&gt;<br>&lt;/template&gt;</pre><p>İyi başladık. Toolbox’ımız hazır bile.</p><p>Şimdi biraz karmaşık olan <a href=\"https://github.com/gayret/form-builder-vuejs/blob/main/src/components/Designer.vue\"><strong>Designer.vue</strong></a> component’imizi kodlayalım.</p><blockquote>Designer, Preview ve Properties component’leri two way binding’e ihtiyaç duyuyor. Kullanıcının yapacağı her hareketten ilgili component’lerin haberdar olması gerekiyor. Bunu yapabilmeniz için parent component ile child component arasında two way binding ilişkisi kurmayı biliyor olmamız lazım. Endişelenmeyin onu da anlatmıştım zamanında<br>(bkz: <a href=\"https://safa.medium.com/parent-component-ile-child-component-aras%C4%B1nda-v-model-ili%C5%9Fkisi-kurmak-859db2ee7d79\">Parent Component ile Child Component arasında v-model ilişkisi kurmak</a>)</blockquote><p>Designer component’imizden beklentilerimiz;</p><ul><li>Form ekranını satırlara ve sütunlara bölebilmeli</li><li>Gerektiğinde satır ve sütunların title ve description bilgilerini güncelleyebilmeli</li><li>Toolbox’tan sürüklenme yoluyla alınan field’lar sütunlara bırakıldığında field’ı temsil eden bir card oluşturabilmeli</li><li>Gerektiğinde oluşturulan field’ları silebilmeli</li><li>Satır ve sütunların yerlerini değiştirebilmeli</li><li>Odaklanılan field’ın özellikleri değiştirilebilsin diye, designler üzerindeki field’lara tıklandığında (hiyerarşik olarak) bir üstteki component’i bilgilendirmeli (Bu kısım karmaşık görünebilir, Properties.vue component’ini yazarken daha anlaşılır hale gelecek)</li></ul><p>Toolbox’taki <strong>onDrag </strong>fonksiyonuna benzer bir <strong>onDrop </strong>fonksiyonu yazalım.</p><pre>const onDrop = (e, col) =&gt; {<br> const field = JSON.parse(e.dataTransfer.getData(&#39;text/plain&#39;))<br> col.fields.push(field)<br>}</pre><p>Bu fonksiyon herhangi bir sütunun üzerine bir field bırakıldığında çalışacak. Diğer kabiliyetleri nasıl kazandırdığımı <a href=\"https://github.com/gayret/form-builder-vuejs/blob/main/src/components/Designer.vue\">component’i </a>inceleyerek öğrebilirsiniz.</p><p>Designer component’imiz de hazır.</p><p>Sırada <a href=\"https://github.com/gayret/form-builder-vuejs/blob/main/src/components/Preview.vue\"><strong>Preview.vue</strong></a> var</p><p>Bu component’ten beklentilerimiz şunlar;</p><ul><li>Designer component’inde oluşturulan satır ve sütunları göstermeli</li><li>Bu sütunların içerisindeki field’ları render etmeli.</li></ul><p>Preview componenti’nde VueJS yazarken pek başvurulmayan bir yönteme başvurmamız gerekiyor. HyperScript ile HTML element oluşturmak ve ekranda göstermek.</p><p>Yapması tarif etmekten daha kolay. VueJS içerisinde HyperScript gömülü geliyor. Nasıl kullanılacağı da <a href=\"https://vuejs.org/guide/extras/render-function.html\">dökümanda mevcut</a>. Yine de kısaca Türkçeleştireyim.</p><pre>h(&#39;div&#39;)</pre><p>h fonksiyonuna parametre olarak bir HTML element’in ihtiyaç duyacağı prop’ları geçiyoruz. Aşağıdaki gibi.</p><pre>h(&#39;div&#39;, { class: &#39;bar&#39;, innerHTML: &#39;hello&#39; })</pre><p>Form builder içerisindeki Preview.vue component’i ‘formBuilderJSON’ adlı bir JSON bekliyor. Bunu App.vue içerisinde reactive bir şekilde oluşturup göndermemiz gerekiyor. Kullanıcının oluşturacağı / oluşturduğu form ile ilgili tüm detaylar bu dinamik JSON içerisinde.</p><p>Preview component’i, kendisine verilen JSON’daki fieldları ‘renderer’ fonksiyonu ile ayıklayıp anlamlı çıktılar döndürüyor.</p><pre>const renderer = (payload) =&gt; {<br> const { type, options, value, placeholder } = payload.field<br><br> switch (type) {<br> case &#39;text&#39;:<br> return h(&#39;input&#39;, { type, value, placeholder })<br> case &#39;checkbox&#39;:<br> return h(&#39;input&#39;, { type, value, placeholder })<br> case &#39;radio&#39;:<br> return h(&#39;input&#39;, { type, value, placeholder })<br> case &#39;datetime-local&#39;:<br> return h(&#39;input&#39;, { type, value, placeholder })<br> case &#39;email&#39;:<br> return h(&#39;input&#39;, { type, value, placeholder })<br> case &#39;number&#39;:<br> return h(&#39;input&#39;, { type, value, placeholder })<br> case &#39;password&#39;:<br> return h(&#39;input&#39;, { type, value, placeholder })<br> case &#39;textarea&#39;:<br> return h(&#39;textarea&#39;, { value, placeholder })<br> case &#39;select&#39;:<br> return h(&#39;select&#39;, options.map((option) =&gt; h(&#39;option&#39;, option.label)))<br> default:<br> return h(&#39;div&#39;, &#39;Unknown field type&#39;)<br> }<br>}</pre><p>Bu fonksiyona form builder’ın motoru diyebiliriz. Tüm fieldları özellikleriyle beraber oluşturan ekrana basan fonksiyon bu. İçerisindeki case sayısını artırarak dilediğiniz kadar yaratıcı form elementleri oluşturabilirsiniz. Ben daha az karmaşık olması nedeniyle sınırlı sayıda element örneği verdim.</p><p>Renderer’e kardeş bir fonksiyon daha oluşturup bununla Condition Management yapılabilir. Yani <em>A input’u doluysa B inputu görünür yap</em> gibi kabiliyetler kazandıracaksak buralarda yapmalıyız. Anlatıyı karmaşıklaştırmamak için bu kabiliyeti eklemedim.</p><p><em>Vuhuu en karmaşık component’i yazdık bitirdik. Bizden korkulur :)</em></p><p>Sırada <a href=\"https://github.com/gayret/form-builder-vuejs/blob/main/src/components/Properties.vue\"><strong>Properties.vue</strong></a> var</p><p>Bu component’ten beklentilerimiz;</p><ul><li>Designer içerisinde üzerine tıklanmış (seçilmiş) field’la ilgili bilgileri gösterecek</li><li>Ve bu bilgileri değiştirmemize olanak verecek</li></ul><p>Preview.vue’yu yazmış biri için bu çocuk oyuncağı. App.vue’ya bakarak kendinize yine two way binding yapmamız gerektiğini hatırlatabilirsiniz. <strong>selectedField </strong>adlı object’i App.vue ile Properties.vue arasında getirip götürmemiz lazım. Böylece kullanıcı field’la ilgili yaptığı değişikliği anlık olarak Preview modunda görüntüleyebilecek.</p><p>Properties.vue içerisinde elimizdeki field’ın ayarlarını yapabileceği elementleri oluşturalım.</p><pre>&lt;div class=&quot;settings&quot;&gt;<br> &lt;h4&gt;Field properties&lt;/h4&gt;<br> &lt;div class=&quot;propertie&quot;&gt;<br> &lt;div class=&quot;propertie-header&quot;&gt;<br> &lt;div class=&quot;icon-and-title&quot;&gt;<br> &lt;Icon size=&quot;30px&quot; :name=&quot;field.icon&quot; :key=&quot;field.icon&quot; /&gt;<br> &lt;input type=&quot;text&quot; v-model=&quot;field.title&quot;&gt;<br> &lt;/div&gt;<br> &lt;div class=&quot;id&quot;&gt;{{ field.id }}&lt;/div&gt;<br> &lt;/div&gt;<br> &lt;div class=&quot;propertie-content&quot;&gt;<br> &lt;div class=&quot;propertie-row&quot;&gt;<br> &lt;div class=&quot;type&quot; v-if=&quot;isInput(field.type)&quot;&gt;<br> &lt;label for=&quot;type&quot;&gt;Type&lt;/label&gt;<br> &lt;select name=&quot;type&quot; id=&quot;type&quot; v-model=&quot;field.type&quot;&gt;<br> &lt;option value=&quot;text&quot;&gt;Text&lt;/option&gt;<br> &lt;option value=&quot;number&quot;&gt;Number&lt;/option&gt;<br> &lt;option value=&quot;email&quot;&gt;Email&lt;/option&gt;<br> &lt;option value=&quot;password&quot;&gt;Password&lt;/option&gt;<br> &lt;option value=&quot;datetime-local&quot;&gt;Datetime&lt;/option&gt;<br> &lt;/select&gt;<br> &lt;/div&gt;<br><br> &lt;div class=&quot;value&quot; v-if=&quot;isInput(field.type) || field.type === &#39;textarea&#39;&quot;&gt;<br> &lt;label for=&quot;value&quot;&gt;Value&lt;/label&gt;<br> &lt;input type=&quot;text&quot; v-model=&quot;field.value&quot;&gt;<br> &lt;/div&gt;<br><br> &lt;div class=&quot;placeholder&quot; v-if=&quot;isInput(field.type) || field.type === &#39;textarea&#39;&quot;&gt;<br> &lt;label for=&quot; placeholder&quot;&gt;Placeholder&lt;/label&gt;<br> &lt;input type=&quot;text&quot; v-model=&quot;field.placeholder&quot;&gt;<br> &lt;/div&gt;<br><br> &lt;div class=&quot;options&quot; v-if=&quot;field.type === &#39;select&#39;&quot;&gt;<br> &lt;label for=&quot;options&quot;&gt;Options&lt;/label&gt;<br> &lt;div class=&quot;option&quot; v-for=&quot;(option, optionIndex) in field.options&quot; :key=&quot;option.id&quot;&gt;<br> &lt;input type=&quot;text&quot; v-model=&quot;option.label&quot;&gt;<br> &lt;button class=&quot;btn&quot; @click=&quot;onRemoveOption(field.options, optionIndex)&quot;&gt;<br> &lt;Icon name=&quot;close&quot; /&gt;<br> &lt;/button&gt;<br> &lt;/div&gt;<br> &lt;button class=&quot;btn&quot; @click=&quot;onAddOption(field.options)&quot;&gt;<br> &lt;Icon name=&quot;add&quot; /&gt;<br> Add Option<br> &lt;/button&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br>&lt;/div&gt;</pre><p>Kullanıcının seçtiği elementin arka plan rengini ve/veya yazı rengini değiştirebilmesini istiyorsak “color” type’lı inputlar da ekleyelim.</p><pre>&lt;div class=&quot;design&quot;&gt;<br> &lt;h4&gt;Design properties&lt;/h4&gt;<br> &lt;div class=&quot;propertie&quot;&gt;<br> &lt;div class=&quot;background-color&quot;&gt;<br> &lt;label for=&quot;background-color&quot;&gt;Background color&lt;/label&gt;<br> &lt;input type=&quot;color&quot; v-model=&quot;field.style.backgroundColor&quot;&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br> &lt;div class=&quot;propertie&quot;&gt;<br> &lt;div class=&quot;color&quot;&gt;<br> &lt;label for=&quot;color&quot;&gt;Font color&lt;/label&gt;<br> &lt;input type=&quot;color&quot; v-model=&quot;field.style.color&quot;&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br>&lt;/div&gt;</pre><p>Hepsi bu kadar. Artık VueJS ile yazılmış bir form builder’ımız var.</p><p><strong>GitHub Repo</strong>: <a href=\"https://github.com/gayret/form-builder-vuejs\">https://github.com/gayret/form-builder-vuejs</a></p><p><strong>Live</strong>: <a href=\"https://form-builder-vuejs.netlify.app\">https://form-builder-vuejs.netlify.app</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=87527be943bd\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " FrontEnd’de çok şey değişiyor: SPA öldü, yaşasın SSR "
          },
          "link": "https://safa.medium.com/frontendde-%C3%A7ok-%C5%9Fey-de%C4%9Fi%C5%9Fiyor-spa-%C3%B6ld%C3%BC-ya%C5%9Fas%C4%B1n-ssr-732a897ab107?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/732a897ab107",
          "category": [
            {
              "__cdata": " ssrs "
            },
            {
              "__cdata": " nextjs "
            },
            {
              "__cdata": " sap "
            },
            {
              "__cdata": " vuejs "
            },
            {
              "__cdata": " react "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Wed, 29 Mar 2023 11:49:22 GMT",
          "updated": "2023-03-29T11:53:40.612Z",
          "encoded": {
            "__cdata": " <figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/1*T_hdLmcueDAkcMo_2YQCUg.png\" /><figcaption>Görsel Kaynağı: <a href=\"https://www.velv.pt/updates/server-side-rendering\">https://www.velv.pt/updates/server-side-rendering</a></figcaption></figure><p>Malumunuz ReactJS, web uygulamaları geliştirirken kullanılan en popüler JavaScript kütüphanesi. Son zamanlarda, ReactJS yerine NextJS kullanımının teşvik edildiğini duymuş olabilirsiniz. Bunun sebebi ReactJS’in <strong>yeni </strong>dökümanında yer alan <strong>Installation </strong>kısmı. Burada artık <em>create-react-app</em> yerine <strong>create-next-app</strong> yazıyor.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/210/1*KUpra0uvIf_-MVQWiQm1Ew.png\" /><figcaption><a href=\"https://react.dev/learn/start-a-new-react-project\">https://react.dev/learn/start-a-new-react-project</a></figcaption></figure><p>Bu gelişme ile birlikte, yakın gelecekte SPA’nın biteceğini, SSR’ın popülerleşeceğini düşünmek yanlış olmaz. Çünkü ReactJS, FrontEnd dünyasını domine eden bir kütüphane, hem çok sayıda developer tarafından kullanılıyor hem de alternatifi diğer framework’ler (VueJS vb.) ReactJS’in izinden gidiyor.</p><h3>Nedir bu SPA?</h3><p><strong>S</strong>ingle-<strong>P</strong>age <strong>A</strong>pplication, tek bir HTML sayfası ve JavaScript kullanarak web uygulamasının tüm içeriğini dinamik olarak oluşturur. Kullanıcılar bu tek sayfa üzerinde gezinirler ve sayfa yenileme işlemi gerektirmez. SPA kullanımı, daha iyi performans, daha hızlı kullanıcı arayüzü ve daha iyi kullanıcı deneyimi gibi avantajlar sunar.</p><p>Ancak, SPA’lar bazı dezavantajlar da taşır. Örneğin, arama motorları için optimize edilmiş sayfaların oluşturulması zordur. Ayrıca, yavaş internet bağlantılarına sahip kullanıcılar için, SPA’lar yüklenme süreleri nedeniyle yavaş veya kullanılamaz hale gelebilirler.</p><h3>Peki SSR nedir?</h3><p><strong>S</strong>erver-<strong>S</strong>ide <strong>R</strong>endering, web uygulamasının sunucu tarafında oluşturulan HTML sayfalarını kullanarak uygulamanın içeriğini ortaya koyar. Bu sayede, sunucu tarafında oluşturulan HTML sayfaları arama motorları tarafından daha iyi indekslenebilir ve daha iyi SEO sağlar. Ayrıca, yavaş internet bağlantılarına sahip kullanıcılar için bile sayfa yükleme süresi oldukça iyidir.</p><p>NextJS, ReactJS’in üzerine inşa edilen bir framework’tür. NextJS, hem SPA hem de SSR kullanımını destekler ve kullanıcılara en iyi deneyimi sağlamak için otomatik olarak doğru yönlendirmeyi yapar. NextJS, SPA’nın sağladığı avantajları korurken, SSR’nin sağladığı avantajları da sunar. Bu nedenle, NextJS kullanımı SPA’ya kıyasla daha önerilen bir yöntemdir.</p><h3>VueJS cephesinde neler olacak?</h3><p>VueJS de rakibi ReactJS gibi SSR framework sağlıyor. Adı da benziyor üstelik, NuxtJS. Ancak NuxtJS, NextJS’e kıyasla daha az stabil ve sektörde pek tercih edilmiyor. Teknik olarak aynı şeyi yapıyor olsalar da NextJS’in metodolojileri daha çok kabul görüyor.</p><p>Öyle sanıyorum ki, VueJS’in de SPA’dan SSR’a geçiş planı vardır ancak ReactJS’in bu beklenmedik hamlesi sonucunda hızlıca pozisyon alacak kadar hazır değildir.</p><p>Tüm bu gelişmeler VueJS, Svelte ve AngularJS gibi SPA teknolojilerinin sonunun habercisi olabilir.</p><p>Özetle sevelim ya da sevmeyelim, SSR teknolojilerine geçiş yapmak zorunda kalacağız.</p><h3>SSR’a geçişimiz iyi mi kötü mü?</h3><h3>Developer deneyimi</h3><p>Developer deneyimi açısından SSR uzun vadede daha verimli ve keyifli bir teknoloji. Çünkü SPA’larda tabiri uygunsa <a href=\"https://tr.wiktionary.org/wiki/Her_yi%C4%9Fidin_bir_yo%C4%9Furt_yiyi%C5%9Fi_vard%C4%B1r\">her yiğit kafasına göre yoğurt yiyor</a>. SSR (NuxtJS bile) çok daha katı kuralların olduğu bir development süreci tanıyor. Böylece SSR ile geliştirilmiş projelere dahil olduğumuzda saçımızı başımızı daha az yoluyoruz. Yine de SPA’ya çok alışmış olan developerlar özellikle API isteklerinin sonuçlarını organize ederken browser’ın console’unu kullanamadıkları için SSR’a ilk bakışlarında yabancılık çekecekler.</p><h3>Kullanıcı deneyimi</h3><p>Aynı işi yapan, doğru düzgün geliştirimiş bir SPA ve SSR projesini kullanıcıya versek, muhtemelen aralarındaki farkı pek ayırt edemez ancak sayfalar yüklenirken neredeyse beklenmemesi, sayfaların içerisindeki component’ler ile birlikte çat diye hazır oluşu gibi detaylar düşünüldüğünde, kullanıcı da SSR’dan daha çok keyif alacaktır.</p><p><em>Bu makale yazılırken yer yer </em><strong><em>ChatGPT</em></strong><em>’den faydalanılmıştır.</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=732a897ab107\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " Hemen kullanabileceğiniz 4 yeni HTML element "
          },
          "link": "https://safa.medium.com/hemen-kullanabilece%C4%9Finiz-4-yeni-html-element-5b3be5587a67?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/5b3be5587a67",
          "category": [
            {
              "__cdata": " noscript "
            },
            {
              "__cdata": " new-elements "
            },
            {
              "__cdata": " html "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Sun, 18 Sep 2022 20:41:43 GMT",
          "updated": "2022-09-23T05:13:11.270Z",
          "encoded": {
            "__cdata": " <h4>Okullarda üzerine düşülmeyen, detaylarıyla incelenmeyen HTML, verimli kullanıldığında fazladan JS ve CSS yazmaktan kurtaran bir teknoloji.</h4><p>Sanılanın aksine HTML, tüm browser’lar tarafından desteklenen yeni özellikler de kazanıyor. Takip etmekte fayda var.</p><p>Gelin gönül rahatlığıyla kullanabileceğiniz 4 yeni elementi inceleyelim.</p><h3>Datalist</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/291/1*UKuYI8Ms0JVdvYUDfWUqgg.png\" /></figure><p>Standart input ile kullanıcılardan karmaşık (kuralsız) veriler alabiliriz. En fazla placeholder attribute ile kullanıcıyı bilgilendirerek tam olarak istediğimiz bilginin ne olduğunu belirtebiliriz. Yeni gelen Datalist elementi ile bundan fazlasını yapabiliyoruz. Kullanıcıya seçenekler sunup, bunlar içerisinde arama ve seçme imkanı sunabiliyoruz.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*kIK3d9-vufYV5bgco78mJg.png\" /><figcaption>Kullanılabilen browserlar</figcaption></figure><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodepen.io%2Fgayret%2Fembed%2Fpreview%2FrNvmWrd%3Fdefault-tabs%3Dhtml%252Cresult%26height%3D600%26host%3Dhttps%253A%252F%252Fcodepen.io%26slug-hash%3DrNvmWrd&amp;display_name=CodePen&amp;url=https%3A%2F%2Fcodepen.io%2Fgayret%2Fpen%2FrNvmWrd&amp;image=https%3A%2F%2Fshots.codepen.io%2Fgayret%2Fpen%2FrNvmWrd-512.jpg%3Fversion%3D1663526214&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=codepen\" width=\"800\" height=\"600\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/249f4b235e10674a04f1a0ff0a15a4ea/href\">https://medium.com/media/249f4b235e10674a04f1a0ff0a15a4ea/href</a></iframe><h3>Details</h3><p>Toggle ile açılıp kapanabilen detaylı içerik gösterimini CSS ve/veya JS yardımı olmaksızın yapmanın yolu yoktu. Details elementi çıkıncaya kadar, kullanımı da oldukça kolay.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodepen.io%2Fgayret%2Fembed%2Fpreview%2FOJZmpWw%3Fdefault-tabs%3Dhtml%252Cresult%26height%3D600%26host%3Dhttps%253A%252F%252Fcodepen.io%26slug-hash%3DOJZmpWw&amp;display_name=CodePen&amp;url=https%3A%2F%2Fcodepen.io%2Fgayret%2Fpen%2FOJZmpWw&amp;image=https%3A%2F%2Fshots.codepen.io%2Fgayret%2Fpen%2FOJZmpWw-512.jpg%3Fversion%3D1663532965&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=codepen\" width=\"800\" height=\"600\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/0d90e0e60029bec5da19742a689a0a41/href\">https://medium.com/media/0d90e0e60029bec5da19742a689a0a41/href</a></iframe><h3>Dialog</h3><p>Kullanıcı bir işlem yaparken ya da yaptıktan sonra gerçekleştirilen işlemle ilgili onay almak veya bilgi vermek developer’ın asli görevlerindendir. Şimdiye kadar bunu karmaşık JS komutlarıyla gerçekleştiriyorduk. Artık kullanımı çok kolay olan bir HTML element ile her şey yolunda.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodepen.io%2Fgayret%2Fembed%2Fpreview%2FKKRmWWj%3Fdefault-tabs%3Dhtml%252Cresult%26height%3D600%26host%3Dhttps%253A%252F%252Fcodepen.io%26slug-hash%3DKKRmWWj&amp;display_name=CodePen&amp;url=https%3A%2F%2Fcodepen.io%2Fgayret%2Fpen%2FKKRmWWj&amp;image=https%3A%2F%2Fshots.codepen.io%2Fgayret%2Fpen%2FKKRmWWj-512.jpg%3Fversion%3D1663533167&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=codepen\" width=\"800\" height=\"600\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/830d272c209c7590b20ccf347446194a/href\">https://medium.com/media/830d272c209c7590b20ccf347446194a/href</a></iframe><h3>Figure</h3><p>Bir fotoğraf veya kod parçacığı yayınlarken altına üstüne kısa caption bilgi girmemiz gerektiğinde, ideal görünüm elde etmek için satırlarca CSS yazmamız gerekiyordu. Artık <strong>figure </strong>ve içerisinde <strong>figcaption </strong>elementlerini kullanarak CSS yazmadan ideale en yakın görüntüyü elde etmek mümkün.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodepen.io%2Fgayret%2Fembed%2Fpreview%2FxxjdqrR%3Fdefault-tabs%3Dhtml%252Cresult%26height%3D600%26host%3Dhttps%253A%252F%252Fcodepen.io%26slug-hash%3DxxjdqrR&amp;display_name=CodePen&amp;url=https%3A%2F%2Fcodepen.io%2Fgayret%2Fpen%2FxxjdqrR&amp;image=https%3A%2F%2Fshots.codepen.io%2Fgayret%2Fpen%2FxxjdqrR-512.jpg%3Fversion%3D1663533508&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=codepen\" width=\"800\" height=\"600\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/df8710e3e218295d9b46f7356e1b53fc/href\">https://medium.com/media/df8710e3e218295d9b46f7356e1b53fc/href</a></iframe><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5b3be5587a67\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " Kendi toast mesajınızı yazın "
          },
          "link": "https://safa.medium.com/kendi-toast-mesaj%C4%B1n%C4%B1z%C4%B1-yaz%C4%B1n-a58495cf0f20?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/a58495cf0f20",
          "category": [
            {
              "__cdata": " message "
            },
            {
              "__cdata": " javascript "
            },
            {
              "__cdata": " toast-message "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Sat, 17 Sep 2022 20:06:33 GMT",
          "updated": "2022-09-17T20:07:38.865Z",
          "encoded": {
            "__cdata": " <h4>Web uygulamalarda temel ihtiyaçlardan biri, bir işlem gerçekleşirken veya gerçekleştikten sonra kullanıcının haberdar edilmesidir. Toast mesajlar burada yardımımıza yetişir. Bunu hakkıyla yapan yığınla NPM paket var ancak bazen yeterli olmayabiliyorlar, araya girip bir şeyleri değiştirmemiz gerekiyor. Peki kendimiz yazsak nasıl yazardık?</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/745/1*8HXCSh1MtmxkBM5vqwHUyQ.png\" /></figure><p>Toast mesaj temelde kolayca call edilebilen bir function olmalıdır.</p><pre>message.success(&#39;This is a success message&#39;, &#39;Congratulations!&#39;)</pre><p>Örnekteki gibi call edilebilen bir function işimizi görecektir.</p><h3>Hadi başlayalım</h3><p>Öncelikle toast mesajın ihtiyaç duyacağı HTML elementleri oluşturan ve ekrana basan bir function yazalım.</p><pre><strong>toast-message.ts</strong></pre><pre>function printer(type = &#39;&#39;, message = &#39;&#39;, title = &#39;&#39;, duration = 3) {<br> const toastWrapper = document.createElement(&#39;div&#39;)<br> toastWrapper.classList.add(&#39;toast-wrapper&#39;)<br> toastWrapper.innerHTML = `<br> &lt;div class=&quot;toast ${type}&quot;&gt;<br> &lt;div class=&quot;toast__title&quot;&gt;${title}&lt;/div&gt;<br> &lt;div class=&quot;toast__message&quot;&gt;${message}&lt;/div&gt;<br> &lt;/div&gt;<br>`</pre><pre>toastWrapper.style.animationDuration = `${duration}s`</pre><pre>document.body.appendChild(toastWrapper)</pre><pre>setTimeout(() =&gt; {<br> toastWrapper.remove()<br> }, duration * 1000)<br>}</pre><p>Burada adı geçen elementlere CSS ile çeki düzen verelim.</p><pre><strong>toast.css</strong></pre><pre>.toast-wrapper {<br> position: fixed;<br> inset: 0;<br> top: 1em;<br> height: max-content;<br> display: grid;<br> place-content: center;<br> animation-name: toast-top;<br> animation-fill-mode: forwards;<br> font-size: 0.9em;<br>}</pre><pre>.toast {<br> background-color: #fff;<br> color: #222;<br> box-shadow: 0 0 10px 0 rgba(0, 0, 0, 0.2);<br> padding: 0.5em 1em;<br> border-radius: 0.5em;<br>}</pre><pre>.toast__title {<br> font-size: 1.2em;<br> font-weight: 600;<br> padding: 0.2em 0;<br>}</pre><p>Adı geçen <strong>toast-top</strong> animasyonunu oluşturalım.</p><pre><strong>toast.css</strong></pre><pre><a href=\"http://twitter.com/keyframes\">@keyframes</a> toast-top {<br> 0% {<br> transform: translateY(-100%);<br> }<br> 20% {<br> transform: translateY(0);<br> }<br> 80% {<br> transform: translateY(5%);<br> }<br> 90% {<br> transform: translateY(25%);<br> }<br> 100% {<br> transform: translateY(-200%);<br> }<br>}</pre><p>printer function’umuzu export edelim.</p><pre><strong>toast-message.ts</strong></pre><pre>const message = {<br> info: printer.bind(null, &#39;info&#39;),<br> success: printer.bind(null, &#39;success&#39;),<br> error: printer.bind(null, &#39;error&#39;),<br> warning: printer.bind(null, &#39;warning&#39;),<br>}</pre><pre>export default message</pre><p>Böylece dışarıda import ettikten sonra <strong>message.success</strong> gibi kullanabiliriz.</p><pre><strong>App.vue</strong></pre><pre>&lt;script setup&gt;<br>import message from &#39;./toast-message&#39;<br>&lt;/script&gt;</pre><pre>&lt;template&gt;<br> &lt;button @click=&quot;message.error(&#39;Error message&#39;)&quot;&gt;Error&lt;/button&gt;&lt;/template&gt;</pre><p><strong>GitHub Repo</strong>: <a href=\"https://github.com/gayret/toast-message-in-vuejs\">https://github.com/gayret/toast-message-in-vuejs</a></p><p><strong>Canlı Demo</strong>: <a href=\"https://toast-message.netlify.app/\">https://toast-message.netlify.app/</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a58495cf0f20\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " WebSocket, VueJS’te nasıl kullanılır? (Hazır paket kullanmadan) "
          },
          "link": "https://safa.medium.com/websocket-vuejste-nas%C4%B1l-kullan%C4%B1l%C4%B1r-haz%C4%B1r-paket-kullanmadan-adc7f29424f2?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/adc7f29424f2",
          "category": [
            {
              "__cdata": " javascript "
            },
            {
              "__cdata": " websocket "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Tue, 26 Jul 2022 11:13:21 GMT",
          "updated": "2022-07-26T11:13:21.746Z",
          "encoded": {
            "__cdata": " <h4>Web uygulama geliştirirken, kullanıcının sayfayı yenilemesini beklemeksizin yeni bilgilerden haberdar olmasını gerektiren senaryolarla karşılaşırız. Bu durumlarda başvurduğumuz yöntemlerin başında WebSocket gelir.</h4><p>WebSocket’in oluşturduğu iletişim kanalları sayesinde, kullanıcının herhangi bir istekte bulunmasını beklemeksizin, ekranına yeni bilgiyi gönderebiliriz. Yazışma (<em>WhatsApp, Messenger</em> vb.) uygulamalarının tamamı bu standart ile çalışır.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/668/1*H_yjD_g2PN5CnwDWTJTxAg.png\" /></figure><p><strong>Live Demo</strong>: <a href=\"https://websocket-vuejs.netlify.app/\">https://websocket-vuejs.netlify.app/</a></p><p><strong>GitHub Repo</strong>: <a href=\"https://github.com/gayret/websocket-vuejs\">https://github.com/gayret/websocket-vuejs</a></p><h3>Bir WebSocket kanalına nasıl bağlanılır?</h3><p>İhtiyaç duyacağımız tek şey <em>ws://</em> veya <em>wss://</em> protokolü ile başlayan bir url. Bu url, ilgili kanala doğrudan erişmemizi sağlayacak.</p><p>WebSocket bağlantısı kurmak için çeşitli hazır paketler var ancak mevcut senaryoda üçüncü parti bir pakete ihtiyacımız yok. JavaScript’in sağladığı WebSocket adlı reserved class, tüm aksiyonlarımızı karşılayabiliyor.</p><pre>const socket = new WebSocket(&#39;BURAYA WEBSOCKET URL&#39;)</pre><p>Bu tanımlamayı yaptıktan sonra gelen response’ları yakalamak için <strong>onmessage </strong>fonksiyonunu kullanırız.</p><pre>socket.onmessage = (event) =&gt; {<br> state.responses.push(event.data)<br>}</pre><p>Artık her yeni bilgi, state’imizdeki responses array’imize kaydedilir.</p><p>Mesaj göndermek için ise <strong>send </strong>fonksiyonunu kullanırız.</p><pre>socket.send(&#39;Gönderilecek mesaj&#39;)</pre><p>Bağlantıyı kapatmak için <strong>close </strong>fonksiyonunu kullanırız.</p><pre>socket.close()</pre><p>Bağlantının kapandığını yakalamak için <strong>onclose</strong>,</p><pre>socket.onclose = () =&gt; {<br> console.log(&#39;WebSocket closed&#39;)<br> state.socketConnected = false<br>}</pre><p>Yaşanabilecek hataları yakalamak için <strong>onerror </strong>fonksiyonunu kullanırız.</p><pre>socket.onerror = (error) =&gt; {<br> console.error(error)<br>}</pre><p>Hepsi bu kadar.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=adc7f29424f2\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " VueJS’te TailwindCSS ile Dark Mode ayarı nasıl yapılır "
          },
          "link": "https://safa.medium.com/vuejste-tailwindcss-ile-dark-mode-ayar%C4%B1-nas%C4%B1l-yap%C4%B1l%C4%B1r-e11008ef9672?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/e11008ef9672",
          "category": [
            {
              "__cdata": " dark-mode "
            },
            {
              "__cdata": " vuejs "
            },
            {
              "__cdata": " tailwind-css "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Thu, 07 Jul 2022 17:48:06 GMT",
          "updated": "2022-07-07T17:55:29.944Z",
          "encoded": {
            "__cdata": " <h4>Web uygulamalarına eklenen renk değiştirme opsiyonu son zamanlarda kullanıcı deneyimi (UX) standartlarının bir parçası haline geldi. Eğer projenizde Tailwind CSS Framework’ü kullanıyorsanız bunu ayarlamak çok kolay.</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/637/1*Ud17AFgFSqmsbw61e7BG5A.png\" /></figure><p><em>Bir VueJS projesine Tailwind CSS’in nasıl install edileceğini </em><a href=\"https://safa.medium.com/tailwind-css-vite-ile-olu%C5%9Fturulmu%C5%9F-vuejs-3e-nas%C4%B1l-kurulur-a92ee61c3ec5\"><em>önceki yazılarımda</em></a><em> açıklamıştım. Tailwind CSS ve GitHub Copilot’u birlikte kullanarak kendi UI standartlarınızı yapay zekadan yardım alarak nasıl kısa sürede tanımlayacağınızı da </em><a href=\"https://safa.medium.com/b%C4%B1rak%C4%B1n-ui%C4%B1-yapay-zeka-yazs%C4%B1n-df9afe7e75fe\"><em>yine başka bir yazımda</em></a><em> açıklamıştım.</em></p><p>Live Demo: <a href=\"https://tailwind-css-vuejs-dark-mode.netlify.app/\">https://tailwind-css-vuejs-dark-mode.netlify.app/</a></p><p>GitHub Repo: <a href=\"https://github.com/gayret/tailwind-css-vuejs-dark-mode\">https://github.com/gayret/tailwind-css-vuejs-dark-mode</a></p><h3>Hadi başlayalım</h3><p>Bilindiği üzere Tailwind CSS, reserved class’larla UI tasarımı yönetmemizi sağlayan bir CSS Framework. Dolayısıyla Dark Mode yönetimini de yine class’larla yapacağız.</p><p>Öncelikle Dark Mode yönetimini class ile yapacağımızı tailwind.config.js içerisinde belirtelim.</p><pre><strong>tailwind.config.js</strong></pre><pre>module.exports = {<br> darkMode: &#39;class&#39;,<br>}</pre><p>Dark Mode’a geçildiğindebody arka planının tamamına koyu bir gri rengi atamak istediğimizde aşağıdaki gibi uygulayabiliriz.</p><pre><strong>index.html</strong></pre><pre>&lt;body class=&quot;bg-white dark:bg-gray-800&quot;&gt;<br> &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br> &lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt;<br>&lt;/body&gt;</pre><p>Böylece projemizin varsayılan arka plan rengini white olarak atadık. Dark Mode’a geçildikten sonraki arka plan rengini ise gray-800 diye kodlanan koyu bir gri yaptık.</p><p>Ayarladığımız bu geçişi görmek için yapmamız gereken tek şey, geçişi tetiklemek. Bunun için toggleTheme adlı bir method oluşturalım.</p><pre>const toggleTheme = () =&gt; {<br> state.theme = state.theme === &#39;light&#39; ? &#39;dark&#39; : &#39;light&#39;<br> if (state.theme === &#39;dark&#39;) {<br> document.documentElement.classList.add(&#39;dark&#39;)<br> } else {<br> document.documentElement.classList.remove(&#39;dark&#39;)<br> }<br>}</pre><p>İsteğe bağlı olarak theme bilgisini localStorage’da da tutabiliriz, bunu yaparsak kullanıcının sonraki oturumunda Theme Mode bilgisi hatırlanır ve kullanıcı bıraktığı gibi bulur.</p><p>Bu method’u bir button ile tetikleyebiliriz.</p><pre>&lt;button <a href=\"http://twitter.com/click\">@click</a>=&quot;toggleTheme&quot;&gt;<br> {{ state.theme === &#39;light&#39; ? &#39;Dark&#39; : &#39;Light&#39; }}<br>&lt;/button&gt;</pre><p><strong>Hepsi bu kadar.</strong> Artık dark: ön ekiyle birlikte ekleyeceğiniz tüm Tailwind CSS özellikleri, kullanıcı Dark Mode’a geçtiğinde aktif olacak.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e11008ef9672\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        },
        {
          "title": {
            "__cdata": " Parent Component ile Child Component arasında v-model ilişkisi kurmak "
          },
          "link": "https://safa.medium.com/parent-component-ile-child-component-aras%C4%B1nda-v-model-ili%C5%9Fkisi-kurmak-859db2ee7d79?source=rss-3ede4c648e44------2",
          "guid": "https://medium.com/p/859db2ee7d79",
          "category": [
            {
              "__cdata": " two-way-data-binding "
            },
            {
              "__cdata": " vuejs "
            },
            {
              "__cdata": " custom-component "
            }
          ],
          "creator": {
            "__cdata": " Safa Gayret "
          },
          "pubDate": "Sat, 02 Jul 2022 13:34:36 GMT",
          "updated": "2022-07-02T13:34:36.354Z",
          "encoded": {
            "__cdata": " <h4>VueJS’te componentler arasında iletişim kurmanın onlarca yolu var. v-model bu yollardan oldukça kullanışlı olanı. HTML inputlardaki bilgileri reaktif bir şekilde yakalamak için v-model kullanarak ‘two way binding’ kurarız. Peki HTML input dışında kendi oluşturduğumuz componentle de v-model ile iletişim kurabilir miyiz, evet.</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/900/1*zHeuV1WJzgfTCbOesqEDXA.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/208/1*a0wjUB-cywfCIsmTmgC5Rg.png\" /></figure><p>Senaryo gereği, tüm HTML inputları sarmalayan bir Child Componente ihtiyacımız olsun. Örnek olması amacıyla Parent’ta input kullanacağımız zaman, klasik HTML input kullanmak yerine kendi oluşturduğumuz &lt;child /&gt; elementini kullanmayı arzu ediyoruz.</p><p><strong>Canlı demo</strong>: <a href=\"https://vue-parent-child-component-vmodel.netlify.app/\">https://vue-parent-child-component-vmodel.netlify.app/</a></p><p><strong>GitHub repo</strong>: <a href=\"https://github.com/gayret/vue-parent-child-component-vmodel\">https://github.com/gayret/vue-parent-child-component-vmodel</a></p><h3>Hadi başlayalım</h3><p>Öncelikle <strong>components </strong>klasörü altında <strong>Child.vue</strong> adlı bir dosya oluşturalım.</p><p>VueJS, parent componentle iletişim kuracak child componentin modelValue adında bir prop bekliyor olmasını istiyor. <strong>modelValue </strong>adlı prop üst componentte v-model ile bağlanmış state ile doğrudan ilişki kurabiliyor.</p><pre><strong>Child.vue</strong></pre><pre>&lt;script setup&gt;<br> const props = defineProps({<br> modelValue: String,<br> })<br>&lt;/script&gt;</pre><p>Yakaladığımız bu prop ile <strong>Child.vue</strong> içerisinde oluşturacağımız reaktif state’i ilişkilendirelim.</p><pre>const value = ref(props.modelValue)</pre><p>value adlı state’imizi template içerisindeki bir input’la two way binding yapalım.</p><pre>&lt;template&gt;<br> &lt;input v-model=&quot;value&quot; /&gt;<br>&lt;/template&gt;</pre><p>Böylece Child.vue içerisindeki input, modelValue adlı prop’taki bilgiyle eşitlendi. Ancak henüz bu input içerisindeki bilginin değişimini Parent Component’e iletmiyoruz. Input’taki her değişimi takip etmek için VueJS’in watch reserved fonksiyonunu kullanabileceğimiz gibi, input’a @input eventListener’ı da ekleyerek aynı sonuca ulaşabiliriz. Bu örnekte watch ile yapıyorum.</p><p>Input’taki her değişimi Parent’a dağıtmanın tek yolu emit etmek. Bunun için emit fonksiyonunu define edelim. update:modelValue Parent Component tarafından otomatik olarak yakalanır.</p><pre>const emit = defineEmits([&#39;update:modelValue&#39;])</pre><p>Artık watch ile her değişimi Parent Component’e dağıtabiliriz.</p><pre>watch(value, (newVal) =&gt; {<br> emit(&#39;update:modelValue&#39;, newVal)<br>})</pre><p><strong>Hepsi bu kadar</strong>, oluşturduğumuz Child adlı Component’i herhangi bir Component içerisine import edip v-model ile iletişim kurdurabiliriz.</p><pre><strong>Parent.vue</strong></pre><pre>&lt;child v-model=&quot;someThing&quot; /&gt;</pre><p><strong>GitHub repo</strong>: <a href=\"https://github.com/gayret/vue-parent-child-component-vmodel\">https://github.com/gayret/vue-parent-child-component-vmodel</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=859db2ee7d79\" width=\"1\" height=\"1\" alt=\"\"> "
          }
        }
      ]
    }
  }
}
